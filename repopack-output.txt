This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2024-10-28T01:50:49.943Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
__test__/
  components/
    LearningGoals.test.tsx
  pages/
    UserProfile.test.tsx
app/
  api/
    analyze/
      route.ts
    auth/
      [...nextauth]/
        route.ts
    learning-goals/
      [id]/
        route.ts
      route.ts
    outputs/
      route.ts
    signup/
      route.ts
    transcribe/
      route.ts
  home/
    page.tsx
  login/
    page.tsx
  outputs/
    [id]/
      page.tsx
    new/
      NewOutputClient.tsx
      page.tsx
    page.tsx
  signup/
    page.tsx
  users/
    [userId]/
      error.tsx
      loading.tsx
      page.tsx
  globals.css
  layout.tsx
  page.tsx
components/
  auth/
    LoginForm.tsx
    SignupForm.tsx
  logo/
    variants/
      codev-color.tsx
    CodevLogo.tsx
    constants.ts
    index.ts
    types.ts
  ui/
    avatar.tsx
    badge.tsx
    button.tsx
    card.tsx
    checkbox.tsx
    dropdown-menu.tsx
    form.tsx
    input.tsx
    label.tsx
    navigation-menu.tsx
    progress.tsx
    select.tsx
    separator.tsx
    sheet.tsx
    skeleton.tsx
    tabs.tsx
    toast.tsx
    toaster.tsx
    tooltip.tsx
  AudioRecorder.tsx
  calendar-heatmap.tsx
  HomePage.tsx
  LandingPage.tsx
  LanguageSelect.tsx
  learning-goals.tsx
  navigation.tsx
  NewOutputForm.tsx
  output-analytics.tsx
  output-list.tsx
  OutputDetailPreview.tsx
  OutputListReview.tsx
  providers.tsx
  skill-tags.tsx
  theme-provider.tsx
  theme-toggle.tsx
  web-vitals-reporter.tsx
hooks/
  use-toast.ts
lib/
  auth/
    auth-options.ts
    callbacks.ts
    providers.ts
  api.ts
  db.ts
  gptAnalysis.ts
  prisma.ts
  qiita.ts
  utils.ts
  whisper.ts
prisma/
  migrations/
    20241014070124_init/
      migration.sql
    20241020161545_add_learning_goals/
      migration.sql
    migration_lock.toml
  schema.prisma
public/
  branding/
    favicon.svg
scripts/
  create-test-user.ts
types/
  next-auth.d.ts
.eslintrc.json
.gitignore
babel.config.js
components.json
env.d.ts
global.d.ts
jest.config.js
jest.setup.js
next-env.d.ts
next.config.mjs
package.json
postcss.config.mjs
README.md
tailwind.config.ts
tsconfig-scripts.json
tsconfig.json

================================================================
Repository Files
================================================================

================
File: __test__/components/LearningGoals.test.tsx
================
/// <reference types="jest" />

import '@testing-library/jest-dom'
import { render, screen, fireEvent } from '@testing-library/react'
import { LearningGoals } from '@/components/learning-goals'

const mockGoals = [
  { 
    id: '1', 
    title: 'Learn React', 
    description: 'Master React fundamentals',
    completed: false,
    createdAt: new Date(),
    updatedAt: new Date(),
    userId: 'user1'
  },
  { 
    id: '2', 
    title: 'Master TypeScript', 
    description: 'Understand advanced TypeScript concepts',
    completed: true,
    createdAt: new Date(),
    updatedAt: new Date(),
    userId: 'user1'
  },
]

describe('LearningGoals', () => {
  it('renders learning goals correctly', () => {
    render(<LearningGoals initialGoals={mockGoals} userId="user1" />)
    
    expect(screen.getByText('Learn React')).toBeInTheDocument()
    expect(screen.getByText('Master TypeScript')).toBeInTheDocument()
  })

  it('allows toggling goal completion', () => {
    render(<LearningGoals initialGoals={mockGoals} userId="user1" />)
    
    const checkbox = screen.getByRole('checkbox', { name: 'Learn React' })
    fireEvent.click(checkbox)
    expect(checkbox).toBeChecked()
  })

  it('allows adding new goals', () => {
    render(<LearningGoals initialGoals={mockGoals} userId="user1" />)
    
    const input = screen.getByPlaceholderText('新しい目標')
    const addButton = screen.getByRole('button', { name: '追加' })
    
    fireEvent.change(input, { target: { value: 'Learn Next.js' } })
    fireEvent.click(addButton)
    
    expect(screen.getByText('Learn Next.js')).toBeInTheDocument()
  })
})

================
File: __test__/pages/UserProfile.test.tsx
================
import { render, screen } from '@testing-library/react'
import UserProfilePage from '@/app/users/[userId]/page'

// モックデータ
const mockUser = {
  id: 'user1',
  name: 'John Doe',
  email: 'john@example.com',
  createdAt: new Date('2023-01-01'),
  todayOutputs: 3,
  totalOutputs: 50,
  currentStreak: 7,
  recentOutputs: [],
  learningGoals: [],
  outputCalendar: {},
}

// API関数のモック
jest.mock('@/lib/api', () => ({
  getUserProfile: jest.fn().mockResolvedValue(mockUser),
}))

describe('UserProfilePage', () => {
  it('renders user profile correctly', async () => {
    render(await UserProfilePage({ params: { userId: 'user1' } }))
    
    expect(screen.getByText('John Doe')).toBeInTheDocument()
    expect(screen.getByText('john@example.com')).toBeInTheDocument()
    expect(screen.getByText('Today\'s Outputs')).toBeInTheDocument()
    expect(screen.getByText('3')).toBeInTheDocument()
    expect(screen.getByText('Total Outputs')).toBeInTheDocument()
    expect(screen.getByText('50')).toBeInTheDocument()
    expect(screen.getByText('Current Streak')).toBeInTheDocument()
    expect(screen.getByText('7 days')).toBeInTheDocument()
  })
})

================
File: app/api/analyze/route.ts
================
import { NextRequest, NextResponse } from "next/server";
import { analyzeAndCorrectWithGPT } from "@/lib/gptAnalysis";

export async function POST(request: NextRequest) {
  try {
    const { content, language } = await request.json();

    if (!content || !language) {
      return NextResponse.json(
        { error: "Content and language are required" },
        { status: 400 }
      );
    }

    const analysisResult = await analyzeAndCorrectWithGPT(content, language);
    return NextResponse.json(analysisResult);
  } catch (error) {
    console.error("Error in analyze API:", error);
    return NextResponse.json(
      { error: "Failed to analyze output" },
      { status: 500 }
    );
  }
}

================
File: app/api/auth/[...nextauth]/route.ts
================
import NextAuth from "next-auth";
import { authOptions } from "@/lib/auth/auth-options";

const handler = NextAuth(authOptions);

export { handler as GET, handler as POST };

================
File: app/api/learning-goals/[id]/route.ts
================
import { NextResponse } from 'next/server'
import { prisma } from '@/lib/prisma'

export async function PATCH(
  request: Request,
  { params }: { params: { id: string } }
) {
  const goalId = params.id
  const { completed } = await request.json()

  try {
    const updatedGoal = await prisma.learningGoal.update({
      where: { id: goalId },
      data: { completed },
    })

    return NextResponse.json(updatedGoal)
  } catch (error) {
    console.error('Failed to update learning goal:', error)
    return NextResponse.json({ error: 'Failed to update learning goal' }, { status: 500 })
  }
}

================
File: app/api/learning-goals/route.ts
================
import { NextResponse } from 'next/server'
import { prisma } from '@/lib/prisma'

export async function POST(request: Request) {
  const body = await request.json()
  const { title, userId } = body

  try {
    const newGoal = await prisma.learningGoal.create({
      data: {
        title,
        description: '', // 必要に応じて説明を追加できます
        userId,
      },
    })

    return NextResponse.json(newGoal, { status: 201 })
  } catch (error) {
    console.error('Failed to create learning goal:', error)
    return NextResponse.json({ error: 'Failed to create learning goal' }, { status: 500 })
  }
}

================
File: app/api/outputs/route.ts
================
import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth/auth-options";
import { saveOutput } from "@/lib/db";

export async function POST(request: NextRequest) {
  const session = await getServerSession(authOptions);

  console.log("Session:", session);

  if (!session || !session.user || !session.user.id) {
    return NextResponse.json({ error: "Not authenticated or user ID not found" }, { status: 401 });
  }

  const userId = session.user.id;

  console.log("User ID:", userId);  // デバッグ用

  try {
    const {
      title,
      originalContent,
      correctedContent,
      analysis,
      relatedLinks,
      language,
    } = await request.json();

    console.log("Received data:", {
      title,
      originalContent,
      correctedContent,
      analysis,
      relatedLinks,
      language,
    });

    const output = await saveOutput(
      title,
      originalContent,
      correctedContent,
      analysis,
      relatedLinks,
      session.user.id,
      language
    );

    return NextResponse.json(output);
  } catch (error) {
    console.error("Error saving output:", error);
    return NextResponse.json(
      { error: "Failed to save output" },
      { status: 500 }
    );
  }
}

================
File: app/api/signup/route.ts
================
import { NextRequest, NextResponse } from "next/server";
import { prisma } from "@/lib/prisma";
import bcrypt from "bcryptjs";

export async function POST(req: NextRequest) {
  const { email, password, name } = await req.json();

  try {
    const existingUser = await prisma.user.findUnique({ where: { email } });
    if (existingUser) {
      return NextResponse.json({ message: "このメールアドレスは既に使用されています" }, { status: 400 });
    }

    const hashedPassword = await bcrypt.hash(password, 10);
    const user = await prisma.user.create({
      data: { email, name, password: hashedPassword },
    });

    return NextResponse.json({ message: "User created successfully", userId: user.id }, { status: 201 });
  } catch (error) {
    console.error("Signup error:", error);
    return NextResponse.json({ message: "サーバーエラーが発生しました" }, { status: 500 });
  }
}

================
File: app/api/transcribe/route.ts
================
import { NextRequest, NextResponse } from "next/server";
import { transcribeAudio } from "@/lib/whisper";
import OpenAI from "openai";

export async function POST(request: NextRequest) {
  try {
    const formData = await request.formData();
    const audioFile = formData.get("audio") as File;
    const language = formData.get("language") as string;

    if (!audioFile) {
      return NextResponse.json(
        { error: "No audio file provided" },
        { status: 400 }
      );
    }

    // デバッグ情報の追加
    console.log('Received audio file:', {
      type: audioFile.type,
      size: audioFile.size,
      name: audioFile.name
    });

    // Content-Typeが正しく設定されていることを確認
    if (!audioFile.type.startsWith('audio/')) {
      return NextResponse.json(
        { error: "Invalid content type. Must be audio/*" },
        { status: 400 }
      );
    }

    // ファイルの内容を確認
    const arrayBuffer = await audioFile.arrayBuffer();
    console.log('File content length:', arrayBuffer.byteLength);

    const transcription = await transcribeAudio(audioFile);
    
    if (!transcription) {
      throw new Error("Transcription result is empty");
    }

    // ファイル名とContent-Typeの整合性チェック
    const fileExtension = audioFile.name.split('.').pop()?.toLowerCase();
    const expectedExtension = audioFile.type.split('/')[1];
    if (fileExtension !== expectedExtension) {
      console.warn(`File extension (${fileExtension}) doesn't match content type (${expectedExtension})`);
    }

    return NextResponse.json({ text: transcription, language: language });
  } catch (error) {
    console.error("Error in transcribe API:", error);
    // エラーメッセージをより詳細に
    const errorMessage = error instanceof Error ? error.message : "Unknown error";
    const errorDetails = error instanceof OpenAI.APIError ? {
      status: error.status,
      code: error.code,
      type: error.type
    } : {};
    return NextResponse.json(
      { 
        error: "Failed to transcribe audio",
        message: errorMessage,
        details: errorDetails
      },
      { status: 500 }
    );
  }
}

================
File: app/home/page.tsx
================
import { getServerSession } from "next-auth/next"
import { authOptions } from "@/lib/auth/auth-options";
import HomePage from "@/components/HomePage"
import { redirect } from "next/navigation";

export default async function Home() {
  const session = await getServerSession(authOptions)

  if (!session) {
    redirect("/");
  }

  return <HomePage />
}

================
File: app/login/page.tsx
================
import { Metadata } from 'next'
import LoginForm from '@/components/auth/LoginForm'

export const metadata: Metadata = {
  title: 'ログイン',
  description: 'アカウントにログインしてください。',
}

export default function LoginPage() {
  return (
    <div className="container mx-auto px-4 py-8">
      <LoginForm />
    </div>
  )
}

================
File: app/outputs/[id]/page.tsx
================
import React from "react";
import { getOutputById } from "@/lib/db";
import OutputDetailPreview from "@/components/OutputDetailPreview";


interface OutputPageProps {
  params: { id: string };
}

export default async function OutputPage({ params }: OutputPageProps) {
  const output = await getOutputById(params.id);

  if (!output) {
    return <div>出力が見つかりません</div>
  }

  return (
    <OutputDetailPreview output={output} />
  );
}

================
File: app/outputs/new/NewOutputClient.tsx
================
"use client";

import React, { useState } from "react";
import { useSession } from "next-auth/react";
import { useRouter } from "next/navigation";
import { toast } from "@/hooks/use-toast";
import NewOutputForm from "@/components/NewOutputForm";

const NewOutputClient: React.FC = () => {
  const [processingStage, setProcessingStage] = useState<string | null>(null);
  const [selectedLanguage, setSelectedLanguage] = useState("");
  const { data: session } = useSession();
  const router = useRouter();

  const handleRecordingComplete = async (audioFile: File) => {
    if (!session?.user?.id) {
      toast({
        title: "認証エラー",
        description: "ログインが必要です。セッションまたはユーザーIDが見つかりません。",
        variant: "destructive",
      });
      router.push("/login");
      return;
    }

    if (!selectedLanguage) {
      toast({
        title: "言語選択エラー",
        description: "言語を選択してください。",
        variant: "destructive",
      });
      return;
    }

    try {
      const formData = new FormData();
      formData.append("audio", audioFile);

      console.log("Sending audio file:", {
        name: audioFile.name,
        type: audioFile.type,
        size: audioFile.size
      });

      // 音声認識
      setProcessingStage("音声認識中");
      const transcribeResponse = await fetch("/api/transcribe", {
        method: "POST",
        body: formData,
      });

      if (!transcribeResponse.ok) {
        const errorData = await transcribeResponse.json();
        throw new Error(`Transcription failed: ${errorData.error}`);
      }

      const { text: transcription } = await transcribeResponse.json();

      // GPTによる分析_修正_提案
      setProcessingStage("分析中");
      const analyzeResponse = await fetch("/api/analyze", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          content: transcription,
          language: selectedLanguage,
        }),
      });

      if (!analyzeResponse.ok) {
        throw new Error("Analysis failed");
      }

      const analysisResult = await analyzeResponse.json();

      // 結果をデータベースに保存
      setProcessingStage("保存中");
      const saveResponse = await fetch("/api/outputs", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          title: analysisResult.title,
          originalContent: transcription,
          correctedContent: analysisResult.correctedText,
          analysis: analysisResult.analysis,
          relatedLinks: analysisResult.relatedLinks,
          language: selectedLanguage,
        }),
      });

      if (!saveResponse.ok) {
        throw new Error("Failed to save output");
      }

      const { id } = await saveResponse.json();

      toast({
        title: "処理完了",
        description: "アウトプットが正常に保存されました。",
      });
      router.push(`/outputs/${id}`);
    } catch (error) {
      console.error("Error during processing:", error);
      toast({
        title: "エラー",
        description: `処理中にエラーが発生しました: ${(error as Error).message}`,
        variant: "destructive",
      });
    } finally {
      setProcessingStage(null);
    }
  };

  const handleLanguageChange = (language: string) => {
    setSelectedLanguage(language);
  };

  return (
    <NewOutputForm
      selectedLanguage={selectedLanguage}
      processingStage={processingStage}
      onLanguageChange={handleLanguageChange}
      onRecordingComplete={handleRecordingComplete}
    />
  );
};

export default NewOutputClient;

================
File: app/outputs/new/page.tsx
================
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth/auth-options";
import { redirect } from "next/navigation";
import NewOutputClient from "./NewOutputClient";

export default async function NewOutputPage() { 
  const session = await getServerSession(authOptions);

  if (!session) {
    redirect("/login");
  }

  return <NewOutputClient />;
}

================
File: app/outputs/page.tsx
================
import React from "react";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth/auth-options";
import { getOutputs } from "@/lib/db";
import { redirect } from "next/navigation";
import OutputListReview from "@/components/OutputListReview";

export default async function OutputsPage() {
  const session = await getServerSession(authOptions);

  if (!session?.user?.id) {
    return redirect("/login");
  }


  const outputs = await getOutputs(session.user.id);
  console.log(outputs)
  
  return <OutputListReview outputs={outputs} />;
}

================
File: app/signup/page.tsx
================
import { Metadata } from 'next'
import SignupForm from '@/components/auth/SignupForm'

export const metadata: Metadata = {
  title: 'サインアップ',
  description: '新しいアカウントを作成してください。',
}

export default function SignupPage() {
  return (
    <div className="container mx-auto px-4 py-8">
      <SignupForm />
    </div>
  )
};

================
File: app/users/[userId]/error.tsx
================
'use client'

import { useEffect } from 'react'
import { Button } from "@/components/ui/button"

export default function Error({
  error,
  reset,
}: {
  error: Error
  reset: () => void
}) {
  useEffect(() => {
    console.error(error)
  }, [error])

  return (
    <div className="container mx-auto px-4 py-8 text-center">
      <h2 className="text-2xl font-bold mb-4">Something went wrong!</h2>
      <p className="mb-4">{error.message}</p>
      <Button onClick={() => reset()}>Try again</Button>
    </div>
  )
}

================
File: app/users/[userId]/loading.tsx
================
import { Skeleton } from "@/components/ui/skeleton"

export default function Loading() {
  return (
    <div className="container mx-auto px-4 py-8">
      <div className="grid gap-6 md:grid-cols-4">
        <div className="md:col-span-3">
          <Skeleton className="h-[200px] w-full" />
        </div>
        <Skeleton className="h-[200px] w-full" />
        <Skeleton className="h-[300px] w-full md:col-span-4" />
        <Skeleton className="h-[400px] w-full md:col-span-3" />
        <Skeleton className="h-[200px] w-full" />
        <Skeleton className="h-[200px] w-full md:col-span-2" />
        <Skeleton className="h-[300px] w-full md:col-span-4" />
      </div>
    </div>
  )
}

================
File: app/users/[userId]/page.tsx
================
import React from 'react';
import { notFound } from 'next/navigation';
import { getUserProfile } from '@/lib/api';
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from "@/components/ui/card";
import { CalendarHeatmap } from '@/components/calendar-heatmap';
import { OutputList } from '@/components/output-list';
import { SkillTags } from '@/components/skill-tags';
import { LearningGoals } from '@/components/learning-goals';
import dynamic from 'next/dynamic';


const OutputAnalytics = dynamic(() => import('@/components/output-analytics').then(mod => mod.OutputAnalytics),{loading: () => <p>Loading analytics...</p>});

export default async function UserProfilePage({ params }: { params: { userId: string } }) {
  const user = await getUserProfile(params.userId);
  
  if (!user) {
    notFound();
  }

  const calendarData = Object.entries(user.outputCalendar).map(([date, count]) => ({ date, count }));
  const skills = user.outputs.reduce((acc, output) => {
    if (!acc.includes(output.language)) {
      acc.push(output.language);
    }
    return acc;
  }, [] as string[]);

  return (
    <div className="container mx-auto px-4 py-8">
      <h1 className="text-3xl font-bold mb-6">ユーザープロフィール</h1>
      <div className="grid gap-6 grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4">
        {/* User Profile Card */}
        <Card className="col-span-full sm:col-span-2 md:col-span-3">
          <CardHeader>
            <div className="flex items-center space-x-4">
              <Avatar className="h-20 w-20">
                <AvatarImage src="/avatar-placeholder.png" alt="" />
                <AvatarFallback>{user.name ? user.name[0].toUpperCase() : 'U'}</AvatarFallback>
              </Avatar>
              <div>
                <CardTitle><h2>{user.name}</h2></CardTitle>
                <CardDescription>{user.email}</CardDescription>
                <p className="text-sm text-muted-foreground">登録日: {user.createdAt.toLocaleDateString()}</p>
              </div>
            </div>
          </CardHeader>
          <CardContent>
            <div className="grid gap-4 md:grid-cols-3">
              <div className="text-center">
                <h3 className="text-lg font-semibold">今日のアウトプット</h3>
                <p className="text-3xl font-bold">{user.todayOutputs}</p>
              </div>
              <div className="text-center">
                <h3 className="text-lg font-semibold">総アウトプット数</h3>
                <p className="text-3xl font-bold">{user.totalOutputs}</p>
              </div>
              <div className="text-center">
                <h3 className="text-lg font-semibold">現在のストリーク</h3>
                <p className="text-3xl font-bold">{user.currentStreak} 日</p>
              </div>
            </div>
          </CardContent>
        </Card>

        {/* Quick Actions Card */}
        <Card className="col-span-full sm:col-span-2 md:col-span-1">
          <CardHeader>
            <CardTitle><h2>クイックアクション</h2></CardTitle>
          </CardHeader>
          <CardContent className="flex flex-col space-y-2">
            <Button>
              <span aria-hidden="true">新規アウトプットを作成</span>
            </Button>
            <Button variant="outline">
              <span aria-hidden="true">全てのアウトプットを表示</span>
            </Button>
          </CardContent>
        </Card>

        {/* Output Calendar Card */}
        <Card className="col-span-full">
          <CardHeader>
            <CardTitle><h2>アウトプットカレンダー</h2></CardTitle>
          </CardHeader>
          <CardContent>
            <CalendarHeatmap data={calendarData} />
          </CardContent>
        </Card>

        {/* Recent Outputs Card */}
        <Card className="col-span-full md:col-span-3">
          <CardHeader>
            <CardTitle><h2>最近のアウトプット</h2></CardTitle>
          </CardHeader>
          <CardContent>
            <OutputList outputs={user.recentOutputs} />
          </CardContent>
          <CardFooter>
            <Button variant="link">
              <span aria-hidden="true">全てのアウトプットを表示</span>
            </Button>
          </CardFooter>
        </Card>

        {/* Skills Card */}
        <Card className="col-span-full sm:col-span-1">
          <CardHeader>
            <CardTitle><h2>スキル</h2></CardTitle>
          </CardHeader>
          <CardContent>
            <SkillTags skills={skills} />
          </CardContent>
        </Card>

        {/* Learning Goals Card */}
        <Card className="col-span-full sm:col-span-4">
          <CardHeader>
            <CardTitle><h2>学習目標</h2></CardTitle>
          </CardHeader>
          <CardContent>
            <LearningGoals initialGoals={user.learningGoals} userId={user.id} />
          </CardContent>
        </Card>

        {/* Output Analytics Card */}
        <Card className="col-span-full">
          <CardHeader>
            <CardTitle><h2>アウトプット分析</h2></CardTitle>
          </CardHeader>
          <CardContent>
            <OutputAnalytics data={calendarData} />
          </CardContent>
        </Card>
      </div>
    </div>
  );
}

================
File: app/globals.css
================
@tailwind base;
@tailwind components;
@tailwind utilities;

body {
  font-family: Arial, Helvetica, sans-serif;
}

@layer utilities {
  .text-balance {
    text-wrap: balance;
  }
}

@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 0 0% 3.9%;
    --card: 0 0% 100%;
    --card-foreground: 0 0% 3.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 0 0% 3.9%;
    --primary: 0 0% 9%;
    --primary-foreground: 0 0% 98%;
    --secondary: 0 0% 96.1%;
    --secondary-foreground: 0 0% 9%;
    --muted: 0 0% 96.1%;
    --muted-foreground: 0 0% 45.1%;
    --accent: 0 0% 96.1%;
    --accent-foreground: 0 0% 9%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 0 0% 98%;
    --border: 0 0% 89.8%;
    --input: 0 0% 89.8%;
    --ring: 0 0% 3.9%;
    --chart-1: 12 76% 61%;
    --chart-2: 173 58% 39%;
    --chart-3: 197 37% 24%;
    --chart-4: 43 74% 66%;
    --chart-5: 27 87% 67%;
    --radius: 0.5rem;
  }
  .dark {
    --background: 0 0% 3.9%;
    --foreground: 0 0% 98%;
    --card: 0 0% 3.9%;
    --card-foreground: 0 0% 98%;
    --popover: 0 0% 3.9%;
    --popover-foreground: 0 0% 98%;
    --primary: 0 0% 98%;
    --primary-foreground: 0 0% 9%;
    --secondary: 0 0% 14.9%;
    --secondary-foreground: 0 0% 98%;
    --muted: 0 0% 14.9%;
    --muted-foreground: 0 0% 63.9%;
    --accent: 0 0% 14.9%;
    --accent-foreground: 0 0% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 0 0% 98%;
    --border: 0 0% 14.9%;
    --input: 0 0% 14.9%;
    --ring: 0 0% 83.1%;
    --chart-1: 220 70% 50%;
    --chart-2: 160 60% 45%;
    --chart-3: 30 80% 55%;
    --chart-4: 280 65% 60%;
    --chart-5: 340 75% 55%;
  }
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}

================
File: app/layout.tsx
================
import '@/app/globals.css'
import { ThemeProvider } from "@/components/theme-provider"
import Navigation from "@/components/navigation"
import { Providers } from "@/components/providers"
import { getServerSession } from "next-auth/next"
import { authOptions } from "@/lib/auth/auth-options";
import { Toaster } from "@/components/ui/toaster"
import { WebVitalsReporter } from "@/components/web-vitals-reporter"

export const metadata = {
  title: "Web Developer's Output App",
  description: "Record and analyze your web development learnings",
  icons: {
    icon: [
      { url: '/branding/favicon.svg', type: 'image/svg+xml' }
    ]
  }
}

export default async function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {

  const session = await getServerSession(authOptions)

  return (
    <html lang="en">
      <body>
        <Providers session={session}>
          <ThemeProvider attribute="class" defaultTheme="system" enableSystem>
            <Navigation serverSession={session ?? undefined} />
            <main className="flex-grow">{children}</main>
            <Toaster />
            <WebVitalsReporter />
          </ThemeProvider>
        </Providers>
      </body>
    </html>
  )
}

================
File: app/page.tsx
================
import { getServerSession } from "next-auth/next"
import { authOptions } from "@/lib/auth/auth-options";
import LandingPage from "@/components/LandingPage"
import { redirect } from "next/navigation";


export default async function Page() {
  const session = await getServerSession(authOptions)

  if (!session) {
    return <LandingPage />
  }

  // ログインしている場合はリダイレクト
  redirect("/home");
}

================
File: components/auth/LoginForm.tsx
================
"use client";

import React from "react";
import {signIn} from "next-auth/react"
import { useForm } from "react-hook-form"
import { useRouter } from "next/navigation";

import { getSession } from "next-auth/react";

import { Card, CardHeader, CardTitle, CardDescription, CardContent, CardFooter } from "@/components/ui/card"
import { Form, FormField, FormItem, FormLabel, FormControl } from "@/components/ui/form"
import { Input } from "@/components/ui/input"
import { Button } from "@/components/ui/button"

import { z } from "zod"
import { zodResolver } from "@hookform/resolvers/zod"
import { toast } from "@/hooks/use-toast";

import Link from "next/link";

const formSchema = z.object({
  email: z.string().email(),
  password: z.string().min(8),
})


export default function LoginPage() {
  const router = useRouter();
  const form = useForm<z.infer<typeof formSchema>>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      email: "",
      password: "",
    },
  });

  const onSubmit = async (values: z.infer<typeof formSchema>) => {
    try {
      const result = await signIn("credentials", {
        redirect: false,
        email: values.email,
        password: values.password,
      });

      if (result?.error) {
        toast({
          title: "ログインエラー",
          description: "メールアドレスまたはパスワードが正しくありません。",
          variant: "destructive",
        });
      } else {
        const session = await getSession();
        console.log("Session:", session);
        if (session) {
          router.push("/home");
        } else {
          console.error("セッションの取得に失敗しました");
          toast({
            title: "エラー",
            description: "ログインに成功しましたが、セッションの取得に失敗しました。",
            variant: "destructive",
          });
        }
      }
    } catch (error) {
      console.error("ログインエラー:", error);
      toast({
        title: "エラー",
        description: "ログイン中に問題が発生しました。もう一度お試しください。",
        variant: "destructive",
      });
    }
  };

  return (
    <div className="min-h-screen flex items-center justify-center bg-background">
      <Card className="w-full max-w-md">
        <CardHeader>
          <CardTitle className="text-2xl font-bold text-center">Web Developer&apos;s Output App</CardTitle>
          <CardDescription className="text-center">アカウントにログイン</CardDescription>
        </CardHeader>
        <CardContent>
          <Form {...form}>
            <form onSubmit={form.handleSubmit(onSubmit)}>
              <FormField
                control={form.control}
                name="email"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>メールアドレス</FormLabel>
                    <FormControl>
                      <Input
                        type="email"
                        {...field}
                        placeholder="メールアドレスを入力"
                        required
                      />
                    </FormControl>
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="password"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>パスワード</FormLabel>
                    <FormControl>
                      <Input
                        type="password"
                        {...field}
                        placeholder="パスワードを入力"
                        required
                      />
                    </FormControl>
                  </FormItem>
                )}
              />
              <Button className="w-full mt-4" type="submit">ログイン</Button>
            </form>
          </Form>
        </CardContent>
        <CardFooter className="flex justify-center">
          <Button variant="link" asChild>
            <Link href="/signup">アカウントをお持ちでない方はこちら</Link>
          </Button>
        </CardFooter>
      </Card>
    </div>
  )
}

================
File: components/auth/SignupForm.tsx
================
"use client"

import { useState } from "react"
import Link from "next/link"
import { useRouter } from "next/navigation"
import { zodResolver } from "@hookform/resolvers/zod"
import { useForm } from "react-hook-form"
import * as z from "zod"

import { Button } from "@/components/ui/button"
import {
  Form,
  FormControl,
  FormDescription,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form"
import { Input } from "@/components/ui/input"
import { useToast } from "@/hooks/use-toast"
import { Loader } from "lucide-react"

const formSchema = z.object({
  name: z.string().min(3, {
    message: "ユーザー名は3文字以上である必要があります。",
  }),
  email: z.string().email({
    message: "有効なメールアドレスを入力してください。",
  }),
  password: z.string().min(8, {
    message: "パスワードは8文字以上である必要があります。",
  }),
})

export default function SignUpPage() {
  const [isLoading, setIsLoading] = useState(false)
  const { toast } = useToast()
  const router = useRouter()

  const form = useForm<z.infer<typeof formSchema>>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      name: "",
      email: "",
      password: "",
    },
  })

  async function onSubmit(values: z.infer<typeof formSchema>) {
    setIsLoading(true);
    try {
      const response = await fetch("/api/signup", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(values),
      });
      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.message || "サインアップに失敗しました");
      }
      toast({
        title: "アカウント作成成功",
        description: "ログインページへリダイレクトします。",
      });
      router.push("/login");
    } catch (error) {
      console.error("サインアップエラー:", error);
      toast({
        title: "エラー",
        description: error instanceof Error ? error.message : "アカウントの作成に失敗しました。もう一度お試しください。",
        variant: "destructive",
      });
    } finally {
      setIsLoading(false);
    }
  }

  return (
    <div className="container mx-auto flex h-screen flex-col items-center justify-center">
      <div className="mx-auto flex w-full flex-col justify-center space-y-6 sm:w-[350px]">
        <div className="flex flex-col space-y-2 text-center">
          <h1 className="text-2xl font-semibold tracking-tight">アカウント作成</h1>
          <p className="text-sm text-muted-foreground">
            以下の情報を入力してアカウントを作成してください
          </p>
        </div>
        <Form {...form}>
          <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-8">
            <FormField
              control={form.control}
              name="name"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>ユーザー名</FormLabel>
                  <FormControl>
                    <Input placeholder="name" {...field} />
                  </FormControl>
                  <FormDescription>
                    あなたの公開プロフィールに表示されます
                  </FormDescription>
                  <FormMessage />
                </FormItem>
              )}
            />
            <FormField
              control={form.control}
              name="email"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>メールアドレス</FormLabel>
                  <FormControl>
                    <Input placeholder="name@example.com" type="email" {...field} />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />
            <FormField
              control={form.control}
              name="password"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>パスワード</FormLabel>
                  <FormControl>
                    <Input placeholder="********" type="password" {...field} />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />
            <Button type="submit" className="w-full" disabled={isLoading}>
              {isLoading && (
                <Loader className="mr-2 h-4 w-4 animate-spin" />
              )}
              アカウント作成
            </Button>
          </form>
        </Form>
        <p className="px-8 text-center text-sm text-muted-foreground">
          アカウントをお持ちの方は{" "}
          <Link href="/login" className="underline underline-offset-4 hover:text-primary">
            ログイン
          </Link>
          してください。
        </p>
      </div>
    </div>
  )
}

================
File: components/logo/variants/codev-color.tsx
================
import { cn } from "@/lib/utils"
import Link from "next/link"

export default function CodevLogo({ className }: { className?: string }) {
  return (
    <Link href="/" className={cn("transition-opacity hover:opacity-80", className)}>
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 200 60">
        <defs>
          <linearGradient id="gradient" x1="0%" y1="0%" x2="100%" y2="0%">
            <stop offset="0%" style={{ stopColor: "#3B82F6" }} />
            <stop offset="100%" style={{ stopColor: "#8B5CF6" }} />
          </linearGradient>
        </defs>
        
        <path 
          d="M20 15 L35 30 L20 45" 
          fill="none" 
          stroke="url(#gradient)" 
          strokeWidth="4" 
          strokeLinecap="round" 
          strokeLinejoin="round"
        />
        
        <path d="M45 25 Q50 30 45 35" fill="none" stroke="url(#gradient)" strokeWidth="3.5" strokeLinecap="round"/>
        <path d="M50 20 Q57 30 50 40" fill="none" stroke="url(#gradient)" strokeWidth="3.5" strokeLinecap="round"/>
        <path d="M55 15 Q65 30 55 45" fill="none" stroke="url(#gradient)" strokeWidth="3.5" strokeLinecap="round"/>
        
        <text 
          x="75" 
          y="40" 
          font-family="system-ui, -apple-system, sans-serif" 
          font-weight="600" 
          font-size="28" 
          fill="url(#gradient)"
        >
          codev
        </text>
      </svg>
    </Link>
  )
}

================
File: components/logo/CodevLogo.tsx
================
import { cn } from "@/lib/utils"
import Link from "next/link"

export default function CodevLogo({ className }: { className?: string }) {
  return (
    <Link href="/" className={cn("transition-opacity hover:opacity-80", className)}>
      <svg 
        xmlns="http://www.w3.org/2000/svg" 
        viewBox="0 0 200 60" 
        className="w-24 h-8"
      >
        <g className="stroke-logo-blue"> {/* 絵の部分は常に青色 */}
          <path 
              d="M20 15 L35 30 L20 45" 
            fill="none" 
            className="stroke-primary" 
            strokeWidth="4" 
            strokeLinecap="round" 
            strokeLinejoin="round"
          />
          
          <path 
            d="M45 25 Q50 30 45 35" 
            fill="none" 
            className="stroke-primary" 
            strokeWidth="3.5" 
            strokeLinecap="round"
          />
          <path 
            d="M50 20 Q57 30 50 40" 
            fill="none" 
            className="stroke-primary" 
            strokeWidth="3.5" 
            strokeLinecap="round"
          />
          <path 
            d="M55 15 Q65 30 55 45" 
            fill="none" 
            className="stroke-primary" 
            strokeWidth="3.5" 
            strokeLinecap="round"
            />
        </g>

        <text 
          x="75" 
          y="40" 
          className="fill-primary font-semibold text-[36px]"
          style={{ fontFamily: "system-ui, -apple-system, sans-serif" }}
          >
          codev
        </text>
      </svg>
    </Link>
  )
}

================
File: components/logo/constants.ts
================
// app/components/logo/constants.ts
export const LOGO_SIZES = {
  sm: 'w-24 h-6',
  md: 'w-32 h-8',
  lg: 'w-40 h-10'
} as const

export const LOGO_COLORS = {
  primary: 'stroke-primary fill-primary',
  blue: 'stroke-logo-blue fill-logo-blue',
  white: 'stroke-white fill-white',
  black: 'stroke-black fill-black'
} as const

================
File: components/logo/index.ts
================
export { default as CodevLogo } from './CodevLogo'

================
File: components/logo/types.ts
================
// app/components/logo/types.ts
import { LOGO_SIZES, LOGO_COLORS } from './constants'

export type LogoSize = keyof typeof LOGO_SIZES
export type LogoColor = keyof typeof LOGO_COLORS

export interface LogoProps {
  size?: LogoSize
  color?: LogoColor
  className?: string
}

================
File: components/ui/avatar.tsx
================
"use client"

import * as React from "react"
import * as AvatarPrimitive from "@radix-ui/react-avatar"

import { cn } from "@/lib/utils"

const Avatar = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full",
      className
    )}
    {...props}
  />
))
Avatar.displayName = AvatarPrimitive.Root.displayName

const AvatarImage = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Image>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Image>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Image
    ref={ref}
    className={cn("aspect-square h-full w-full", className)}
    {...props}
  />
))
AvatarImage.displayName = AvatarPrimitive.Image.displayName

const AvatarFallback = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Fallback>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Fallback>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Fallback
    ref={ref}
    className={cn(
      "flex h-full w-full items-center justify-center rounded-full bg-muted",
      className
    )}
    {...props}
  />
))
AvatarFallback.displayName = AvatarPrimitive.Fallback.displayName

export { Avatar, AvatarImage, AvatarFallback }

================
File: components/ui/badge.tsx
================
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground hover:bg-primary/80",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive:
          "border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80",
        outline: "text-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant }), className)} {...props} />
  )
}

export { Badge, badgeVariants }

================
File: components/ui/button.tsx
================
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline:
          "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

export { Button, buttonVariants }

================
File: components/ui/card.tsx
================
import * as React from "react"

import { cn } from "@/lib/utils"

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-lg border bg-card text-card-foreground shadow-sm",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h3
    ref={ref}
    className={cn(
      "text-2xl font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <p
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }

================
File: components/ui/checkbox.tsx
================
"use client"

import * as React from "react"
import * as CheckboxPrimitive from "@radix-ui/react-checkbox"
import { Check } from "lucide-react"

import { cn } from "@/lib/utils"

const Checkbox = React.forwardRef<
  React.ElementRef<typeof CheckboxPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>
>(({ className, ...props }, ref) => (
  <CheckboxPrimitive.Root
    ref={ref}
    className={cn(
      "peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
      className
    )}
    {...props}
  >
    <CheckboxPrimitive.Indicator
      className={cn("flex items-center justify-center text-current")}
    >
      <Check className="h-4 w-4" />
    </CheckboxPrimitive.Indicator>
  </CheckboxPrimitive.Root>
))
Checkbox.displayName = CheckboxPrimitive.Root.displayName

export { Checkbox }

================
File: components/ui/dropdown-menu.tsx
================
"use client"

import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { Check, ChevronRight, Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const DropdownMenu = DropdownMenuPrimitive.Root

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger

const DropdownMenuGroup = DropdownMenuPrimitive.Group

const DropdownMenuPortal = DropdownMenuPrimitive.Portal

const DropdownMenuSub = DropdownMenuPrimitive.Sub

const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup

const DropdownMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </DropdownMenuPrimitive.SubTrigger>
))
DropdownMenuSubTrigger.displayName =
  DropdownMenuPrimitive.SubTrigger.displayName

const DropdownMenuSubContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
DropdownMenuSubContent.displayName =
  DropdownMenuPrimitive.SubContent.displayName

const DropdownMenuContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
))
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName

const DropdownMenuItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName

const DropdownMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
))
DropdownMenuCheckboxItem.displayName =
  DropdownMenuPrimitive.CheckboxItem.displayName

const DropdownMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
))
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName

const DropdownMenuLabel = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName

const DropdownMenuSeparator = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName

const DropdownMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn("ml-auto text-xs tracking-widest opacity-60", className)}
      {...props}
    />
  )
}
DropdownMenuShortcut.displayName = "DropdownMenuShortcut"

export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuRadioGroup,
}

================
File: components/ui/form.tsx
================
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { Slot } from "@radix-ui/react-slot"
import {
  Controller,
  ControllerProps,
  FieldPath,
  FieldValues,
  FormProvider,
  useFormContext,
} from "react-hook-form"

import { cn } from "@/lib/utils"
import { Label } from "@/components/ui/label"

const Form = FormProvider

type FormFieldContextValue<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>
> = {
  name: TName
}

const FormFieldContext = React.createContext<FormFieldContextValue>(
  {} as FormFieldContextValue
)

const FormField = <
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>
>({
  ...props
}: ControllerProps<TFieldValues, TName>) => {
  return (
    <FormFieldContext.Provider value={{ name: props.name }}>
      <Controller {...props} />
    </FormFieldContext.Provider>
  )
}

const useFormField = () => {
  const fieldContext = React.useContext(FormFieldContext)
  const itemContext = React.useContext(FormItemContext)
  const { getFieldState, formState } = useFormContext()

  const fieldState = getFieldState(fieldContext.name, formState)

  if (!fieldContext) {
    throw new Error("useFormField should be used within <FormField>")
  }

  const { id } = itemContext

  return {
    id,
    name: fieldContext.name,
    formItemId: `${id}-form-item`,
    formDescriptionId: `${id}-form-item-description`,
    formMessageId: `${id}-form-item-message`,
    ...fieldState,
  }
}

type FormItemContextValue = {
  id: string
}

const FormItemContext = React.createContext<FormItemContextValue>(
  {} as FormItemContextValue
)

const FormItem = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const id = React.useId()

  return (
    <FormItemContext.Provider value={{ id }}>
      <div ref={ref} className={cn("space-y-2", className)} {...props} />
    </FormItemContext.Provider>
  )
})
FormItem.displayName = "FormItem"

const FormLabel = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root>
>(({ className, ...props }, ref) => {
  const { error, formItemId } = useFormField()

  return (
    <Label
      ref={ref}
      className={cn(error && "text-destructive", className)}
      htmlFor={formItemId}
      {...props}
    />
  )
})
FormLabel.displayName = "FormLabel"

const FormControl = React.forwardRef<
  React.ElementRef<typeof Slot>,
  React.ComponentPropsWithoutRef<typeof Slot>
>(({ ...props }, ref) => {
  const { error, formItemId, formDescriptionId, formMessageId } = useFormField()

  return (
    <Slot
      ref={ref}
      id={formItemId}
      aria-describedby={
        !error
          ? `${formDescriptionId}`
          : `${formDescriptionId} ${formMessageId}`
      }
      aria-invalid={!!error}
      {...props}
    />
  )
})
FormControl.displayName = "FormControl"

const FormDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => {
  const { formDescriptionId } = useFormField()

  return (
    <p
      ref={ref}
      id={formDescriptionId}
      className={cn("text-sm text-muted-foreground", className)}
      {...props}
    />
  )
})
FormDescription.displayName = "FormDescription"

const FormMessage = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, children, ...props }, ref) => {
  const { error, formMessageId } = useFormField()
  const body = error ? String(error?.message) : children

  if (!body) {
    return null
  }

  return (
    <p
      ref={ref}
      id={formMessageId}
      className={cn("text-sm font-medium text-destructive", className)}
      {...props}
    >
      {body}
    </p>
  )
})
FormMessage.displayName = "FormMessage"

export {
  useFormField,
  Form,
  FormItem,
  FormLabel,
  FormControl,
  FormDescription,
  FormMessage,
  FormField,
}

================
File: components/ui/input.tsx
================
import * as React from "react"

import { cn } from "@/lib/utils"

// eslint-disable-next-line @typescript-eslint/no-empty-object-type
export interface InputProps
  extends React.InputHTMLAttributes<HTMLInputElement> {}

const Input = React.forwardRef<HTMLInputElement, InputProps>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Input.displayName = "Input"

export { Input }

================
File: components/ui/label.tsx
================
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
)

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
))
Label.displayName = LabelPrimitive.Root.displayName

export { Label }

================
File: components/ui/navigation-menu.tsx
================
import * as React from "react"
import * as NavigationMenuPrimitive from "@radix-ui/react-navigation-menu"
import { cva } from "class-variance-authority"
import { ChevronDown } from "lucide-react"

import { cn } from "@/lib/utils"

const NavigationMenu = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <NavigationMenuPrimitive.Root
    ref={ref}
    className={cn(
      "relative z-10 flex max-w-max flex-1 items-center justify-center",
      className
    )}
    {...props}
  >
    {children}
    <NavigationMenuViewport />
  </NavigationMenuPrimitive.Root>
))
NavigationMenu.displayName = NavigationMenuPrimitive.Root.displayName

const NavigationMenuList = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.List>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.List
    ref={ref}
    className={cn(
      "group flex flex-1 list-none items-center justify-center space-x-6",
      className
    )}
    {...props}
  />
))
NavigationMenuList.displayName = NavigationMenuPrimitive.List.displayName

const NavigationMenuItem = NavigationMenuPrimitive.Item

const navigationMenuTriggerStyle = cva(
  "group inline-flex h-10 w-max items-center justify-center rounded-md bg-background px-4 py-2 text-sm font-medium transition-colors hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground focus:outline-none disabled:pointer-events-none disabled:opacity-50 data-[active]:bg-accent/50 data-[state=open]:bg-accent/50"
)

const NavigationMenuTrigger = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <NavigationMenuPrimitive.Trigger
    ref={ref}
    className={cn(navigationMenuTriggerStyle(), "group", className)}
    {...props}
  >
    {children}{" "}
    <ChevronDown
      className="relative top-[1px] ml-1 h-3 w-3 transition duration-200 group-data-[state=open]:rotate-180"
      aria-hidden="true"
    />
  </NavigationMenuPrimitive.Trigger>
))
NavigationMenuTrigger.displayName = NavigationMenuPrimitive.Trigger.displayName

const NavigationMenuContent = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Content>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.Content
    ref={ref}
    className={cn(
      "left-0 top-0 w-full data-[motion^=from-]:animate-in data-[motion^=to-]:animate-out data-[motion^=from-]:fade-in data-[motion^=to-]:fade-out data-[motion=from-end]:slide-in-from-right-52 data-[motion=from-start]:slide-in-from-left-52 data-[motion=to-end]:slide-out-to-right-52 data-[motion=to-start]:slide-out-to-left-52 md:absolute md:w-auto ",
      className
    )}
    {...props}
  />
))
NavigationMenuContent.displayName = NavigationMenuPrimitive.Content.displayName

const NavigationMenuLink = NavigationMenuPrimitive.Link

const NavigationMenuViewport = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Viewport>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Viewport>
>(({ className, ...props }, ref) => (
  <div className={cn("absolute left-0 top-full flex justify-center")}>
    <NavigationMenuPrimitive.Viewport
      className={cn(
        "origin-top-center relative mt-1.5 h-[var(--radix-navigation-menu-viewport-height)] w-full overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-90 md:w-[var(--radix-navigation-menu-viewport-width)]",
        className
      )}
      ref={ref}
      {...props}
    />
  </div>
))
NavigationMenuViewport.displayName =
  NavigationMenuPrimitive.Viewport.displayName

const NavigationMenuIndicator = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Indicator>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Indicator>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.Indicator
    ref={ref}
    className={cn(
      "top-full z-[1] flex h-1.5 items-end justify-center overflow-hidden data-[state=visible]:animate-in data-[state=hidden]:animate-out data-[state=hidden]:fade-out data-[state=visible]:fade-in",
      className
    )}
    {...props}
  >
    <div className="relative top-[60%] h-2 w-2 rotate-45 rounded-tl-sm bg-border shadow-md" />
  </NavigationMenuPrimitive.Indicator>
))
NavigationMenuIndicator.displayName =
  NavigationMenuPrimitive.Indicator.displayName

export {
  navigationMenuTriggerStyle,
  NavigationMenu,
  NavigationMenuList,
  NavigationMenuItem,
  NavigationMenuContent,
  NavigationMenuTrigger,
  NavigationMenuLink,
  NavigationMenuIndicator,
  NavigationMenuViewport,
}

================
File: components/ui/progress.tsx
================
"use client"

import * as React from "react"
import * as ProgressPrimitive from "@radix-ui/react-progress"

import { cn } from "@/lib/utils"

const Progress = React.forwardRef<
  React.ElementRef<typeof ProgressPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ProgressPrimitive.Root>
>(({ className, value, ...props }, ref) => (
  <ProgressPrimitive.Root
    ref={ref}
    className={cn(
      "relative h-4 w-full overflow-hidden rounded-full bg-secondary",
      className
    )}
    {...props}
  >
    <ProgressPrimitive.Indicator
      className="h-full w-full flex-1 bg-primary transition-all"
      style={{ transform: `translateX(-${100 - (value || 0)}%)` }}
    />
  </ProgressPrimitive.Root>
))
Progress.displayName = ProgressPrimitive.Root.displayName

export { Progress }

================
File: components/ui/select.tsx
================
"use client"

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { Check, ChevronDown, ChevronUp } from "lucide-react"

import { cn } from "@/lib/utils"

const Select = SelectPrimitive.Root

const SelectGroup = SelectPrimitive.Group

const SelectValue = SelectPrimitive.Value

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
      className
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
))
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName

const SelectScrollUpButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronUp className="h-4 w-4" />
  </SelectPrimitive.ScrollUpButton>
))
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName

const SelectScrollDownButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronDown className="h-4 w-4" />
  </SelectPrimitive.ScrollDownButton>
))
SelectScrollDownButton.displayName =
  SelectPrimitive.ScrollDownButton.displayName

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        "relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        position === "popper" &&
          "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          "p-1",
          position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
))
SelectContent.displayName = SelectPrimitive.Content.displayName

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn("py-1.5 pl-8 pr-2 text-sm font-semibold", className)}
    {...props}
  />
))
SelectLabel.displayName = SelectPrimitive.Label.displayName

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>

    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
))
SelectItem.displayName = SelectPrimitive.Item.displayName

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
SelectSeparator.displayName = SelectPrimitive.Separator.displayName

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
}

================
File: components/ui/separator.tsx
================
"use client"

import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "@/lib/utils"

const Separator = React.forwardRef<
  React.ElementRef<typeof SeparatorPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SeparatorPrimitive.Root>
>(
  (
    { className, orientation = "horizontal", decorative = true, ...props },
    ref
  ) => (
    <SeparatorPrimitive.Root
      ref={ref}
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "shrink-0 bg-border",
        orientation === "horizontal" ? "h-[1px] w-full" : "h-full w-[1px]",
        className
      )}
      {...props}
    />
  )
)
Separator.displayName = SeparatorPrimitive.Root.displayName

export { Separator }

================
File: components/ui/sheet.tsx
================
"use client"

import * as React from "react"
import * as SheetPrimitive from "@radix-ui/react-dialog"
import { cva, type VariantProps } from "class-variance-authority"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const Sheet = SheetPrimitive.Root

const SheetTrigger = SheetPrimitive.Trigger

const SheetClose = SheetPrimitive.Close

const SheetPortal = SheetPrimitive.Portal

const SheetOverlay = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
    ref={ref}
  />
))
SheetOverlay.displayName = SheetPrimitive.Overlay.displayName

const sheetVariants = cva(
  "fixed z-50 gap-4 bg-background p-6 shadow-lg transition ease-in-out data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:duration-300 data-[state=open]:duration-500",
  {
    variants: {
      side: {
        top: "inset-x-0 top-0 border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top",
        bottom:
          "inset-x-0 bottom-0 border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom",
        left: "inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm",
        right:
          "inset-y-0 right-0 h-full w-3/4  border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm",
      },
    },
    defaultVariants: {
      side: "right",
    },
  }
)

interface SheetContentProps
  extends React.ComponentPropsWithoutRef<typeof SheetPrimitive.Content>,
    VariantProps<typeof sheetVariants> {}

const SheetContent = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Content>,
  SheetContentProps
>(({ side = "right", className, children, ...props }, ref) => (
  <SheetPortal>
    <SheetOverlay />
    <SheetPrimitive.Content
      ref={ref}
      className={cn(sheetVariants({ side }), className)}
      {...props}
    >
      {children}
      <SheetPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-secondary">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </SheetPrimitive.Close>
    </SheetPrimitive.Content>
  </SheetPortal>
))
SheetContent.displayName = SheetPrimitive.Content.displayName

const SheetHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-2 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
SheetHeader.displayName = "SheetHeader"

const SheetFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
SheetFooter.displayName = "SheetFooter"

const SheetTitle = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Title>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold text-foreground", className)}
    {...props}
  />
))
SheetTitle.displayName = SheetPrimitive.Title.displayName

const SheetDescription = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Description>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
SheetDescription.displayName = SheetPrimitive.Description.displayName

export {
  Sheet,
  SheetPortal,
  SheetOverlay,
  SheetTrigger,
  SheetClose,
  SheetContent,
  SheetHeader,
  SheetFooter,
  SheetTitle,
  SheetDescription,
}

================
File: components/ui/skeleton.tsx
================
import { cn } from "@/lib/utils"

function Skeleton({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div
      className={cn("animate-pulse rounded-md bg-muted", className)}
      {...props}
    />
  )
}

export { Skeleton }

================
File: components/ui/tabs.tsx
================
"use client"

import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "@/lib/utils"

const Tabs = TabsPrimitive.Root

const TabsList = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn(
      "inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground",
      className
    )}
    {...props}
  />
))
TabsList.displayName = TabsPrimitive.List.displayName

const TabsTrigger = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      "inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm",
      className
    )}
    {...props}
  />
))
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName

const TabsContent = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      className
    )}
    {...props}
  />
))
TabsContent.displayName = TabsPrimitive.Content.displayName

export { Tabs, TabsList, TabsTrigger, TabsContent }

================
File: components/ui/toast.tsx
================
"use client"

import * as React from "react"
import * as ToastPrimitives from "@radix-ui/react-toast"
import { cva, type VariantProps } from "class-variance-authority"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const ToastProvider = ToastPrimitives.Provider

const ToastViewport = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Viewport>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Viewport
    ref={ref}
    className={cn(
      "fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]",
      className
    )}
    {...props}
  />
))
ToastViewport.displayName = ToastPrimitives.Viewport.displayName

const toastVariants = cva(
  "group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full",
  {
    variants: {
      variant: {
        default: "border bg-background text-foreground",
        destructive:
          "destructive group border-destructive bg-destructive text-destructive-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

const Toast = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &
    VariantProps<typeof toastVariants>
>(({ className, variant, ...props }, ref) => {
  return (
    <ToastPrimitives.Root
      ref={ref}
      className={cn(toastVariants({ variant }), className)}
      {...props}
    />
  )
})
Toast.displayName = ToastPrimitives.Root.displayName

const ToastAction = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Action>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Action
    ref={ref}
    className={cn(
      "inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-secondary focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive",
      className
    )}
    {...props}
  />
))
ToastAction.displayName = ToastPrimitives.Action.displayName

const ToastClose = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Close>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Close
    ref={ref}
    className={cn(
      "absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600",
      className
    )}
    toast-close=""
    {...props}
  >
    <X className="h-4 w-4" />
  </ToastPrimitives.Close>
))
ToastClose.displayName = ToastPrimitives.Close.displayName

const ToastTitle = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Title>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Title
    ref={ref}
    className={cn("text-sm font-semibold", className)}
    {...props}
  />
))
ToastTitle.displayName = ToastPrimitives.Title.displayName

const ToastDescription = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Description>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Description
    ref={ref}
    className={cn("text-sm opacity-90", className)}
    {...props}
  />
))
ToastDescription.displayName = ToastPrimitives.Description.displayName

type ToastProps = React.ComponentPropsWithoutRef<typeof Toast>

type ToastActionElement = React.ReactElement<typeof ToastAction>

export {
  type ToastProps,
  type ToastActionElement,
  ToastProvider,
  ToastViewport,
  Toast,
  ToastTitle,
  ToastDescription,
  ToastClose,
  ToastAction,
}

================
File: components/ui/toaster.tsx
================
"use client"

import { useToast } from "@/hooks/use-toast"
import {
  Toast,
  ToastClose,
  ToastDescription,
  ToastProvider,
  ToastTitle,
  ToastViewport,
} from "@/components/ui/toast"

export function Toaster() {
  const { toasts } = useToast()

  return (
    <ToastProvider>
      {toasts.map(function ({ id, title, description, action, ...props }) {
        return (
          <Toast key={id} {...props}>
            <div className="grid gap-1">
              {title && <ToastTitle>{title}</ToastTitle>}
              {description && (
                <ToastDescription>{description}</ToastDescription>
              )}
            </div>
            {action}
            <ToastClose />
          </Toast>
        )
      })}
      <ToastViewport />
    </ToastProvider>
  )
}

================
File: components/ui/tooltip.tsx
================
"use client"

import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"

import { cn } from "@/lib/utils"

const TooltipProvider = TooltipPrimitive.Provider

const Tooltip = TooltipPrimitive.Root

const TooltipTrigger = TooltipPrimitive.Trigger

const TooltipContent = React.forwardRef<
  React.ElementRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Content
    ref={ref}
    sideOffset={sideOffset}
    className={cn(
      "z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
TooltipContent.displayName = TooltipPrimitive.Content.displayName

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }

================
File: components/AudioRecorder.tsx
================
"use client";

import React, { useState, useRef, useCallback, useEffect } from "react";
import { Button } from "@/components/ui/button";
import { toast } from "@/hooks/use-toast";

interface AudioRecorderProps {
  onRecordingComplete: (file: File) => void;
  isDisabled: boolean,
}

const MAX_RECORDING_TIME = 60; // 60秒の最大録音時間

const AudioRecorder: React.FC<AudioRecorderProps> = ({
  onRecordingComplete,
  isDisabled,
}) => {
  const [isRecording, setIsRecording] = useState(false);
  const [recordingTime, setRecordingTime] = useState(0);
  const mediaRecorderRef = useRef<MediaRecorder | null>(null);
  const chunksRef = useRef<Blob[]>([]);
  const timerRef = useRef<NodeJS.Timeout | null>(null);

  const handleToggleRecording = () => {
    if (isDisabled) return;
    setIsRecording(!isRecording);
  };

  const startRecording = useCallback(async () => {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });

      // iOSかどうかを確認
      const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);

      // 適切なMIMEタイプとファイル拡張子の組み合わせを設定
      let mimeType = 'audio/mp4';
      let fileExtension = '.mp4';

      // iOSの場合の特別な処理
      if (isIOS) {
        if (MediaRecorder.isTypeSupported('audio/mp4')) {
          mimeType = 'audio/mp4';
          fileExtension = '.mp4';
        } else if (MediaRecorder.isTypeSupported('audio/mpeg')) {
          mimeType = 'audio/mpeg';
          fileExtension = '.mp3';
        }
      }

      // MediaRecorderのオプション設定
      const options = {
        mimeType: mimeType,
        audioBitsPerSecond: 16000
      };

      console.log(`Using format: ${mimeType} with extension ${fileExtension}`); // デバッグ用

      mediaRecorderRef.current = new MediaRecorder(stream, options);

      mediaRecorderRef.current.ondataavailable = (event) => {
        if (event.data.size > 0) {
          chunksRef.current.push(event.data);
        }
      };

      mediaRecorderRef.current.onstop = () => {
        const finalMimeType = mediaRecorderRef.current?.mimeType || mimeType;
        const blob = new Blob(chunksRef.current, { type: finalMimeType });

        // Blobを新しいFileオブジェクトとして作成（拡張子を合わせる）
        const file = new File([blob], `recording${fileExtension}`, {
          type: finalMimeType,
          lastModified: Date.now()
        });

        console.log('Recording completed:', {
          name: file.name,
          type: file.type,
          size: file.size
        });

        onRecordingComplete(file);
        chunksRef.current = [];
      };

      // 1秒ごとにデータを取得するように設定
      mediaRecorderRef.current.start(1000);
      setRecordingTime(0);
      timerRef.current = setInterval(() => {
        setRecordingTime((prevTime) => {
          if (prevTime >= MAX_RECORDING_TIME - 1) {
            stopRecording();
            return MAX_RECORDING_TIME;
          }
          return prevTime + 1;
        });
      }, 1000);
    } catch (error) {
      console.error("Error starting recording:", error);
      toast({
        title: "録音エラー",
        description: "録音の開始に失敗しました。デバイスの設定を確認してください。",
        variant: "destructive",
      });
    }
  }, [onRecordingComplete]);

  const stopRecording = useCallback(() => {
    if (mediaRecorderRef.current && mediaRecorderRef.current.state === "recording") {
      mediaRecorderRef.current.stop();
      mediaRecorderRef.current.stream
        .getTracks()
        .forEach((track) => track.stop());
    }
    if (timerRef.current) {
      clearInterval(timerRef.current);
    }
    setRecordingTime(0);
  }, []);

  useEffect(() => {
    if (isRecording) {
      startRecording();
    } else {
      stopRecording();
    }
  }, [isRecording, startRecording, stopRecording]);

  return (
    <div>
      <Button
        size="lg"
        className="w-full h-32 text-2xl"
        onClick={handleToggleRecording}
        disabled={isDisabled}
      >
        {isRecording ? "録音停止" : "録音開始"}
      </Button>
      {isRecording && (
        <div className="mt-2 text-center">
          録音時間: {recordingTime}秒 / {MAX_RECORDING_TIME}秒
        </div>
      )}
    </div>
  );
};

export default AudioRecorder;

================
File: components/calendar-heatmap.tsx
================
"use client" // Next.jsのクライアントサイドコンポーネントであることを示す

import { useState, useRef, useEffect } from 'react'
import { format, parseISO, subDays, getDay } from 'date-fns'
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip"

// TypeScriptの型定義：カレンダーデータの形式を指定
type CalendarData = {
  date: string    // 日付（YYYY-MM-DD形式）
  count: number   // その日のアクティビティ数
}

export function CalendarHeatmap({ data = [] }: { data: CalendarData[] }) {
  // Reactの状態管理とrefの設定
  const [, setHoveredDate] = useState<string | null>(null)  // ホバー中の日付を追跡
  const scrollContainerRef = useRef<HTMLDivElement>(null)   // スクロールコンテナへの参照を保持

  // 日付範囲の生成（今日から365日前まで）
  const today = new Date()
  const dateRange = Array.from({ length: 365 }, (_, i) => {
    const date = subDays(today, 364 - i)  // 364日前から今日までの日付を生成
    return format(date, 'yyyy-MM-dd')     // 日付を文字列形式に変換
  })

  // コンポーネントがマウントされた時に実行される副作用
  useEffect(() => {
    // スクロールコンテナが存在する場合、最新のデータ（右端）が表示されるようにスクロール
    if (scrollContainerRef.current) {
      scrollContainerRef.current.scrollLeft = scrollContainerRef.current.scrollWidth
    }
  }, []) // 空の依存配列は、この効果がマウント時にのみ実行されることを示す

  // アクティビティ数に基づいて背景色を決定する関数
  const getColor = (count: number) => {
    // カウントに応じて異なる濃さの緑色を返す
    // dark:は、ダークモード時の色を指定
    if (count === 0) return 'bg-muted'
    if (count < 3) return 'bg-emerald-200 dark:bg-emerald-900'
    if (count < 5) return 'bg-emerald-300 dark:bg-emerald-800'
    if (count < 7) return 'bg-emerald-400 dark:bg-emerald-700'
    return 'bg-emerald-500 dark:bg-emerald-600'
  }

  // 日付データを週単位でグループ化する処理
  const weeks: string[][] = []        // 週ごとのデータを格納する2次元配列
  let currentWeek: string[] = []      // 現在処理中の週のデータ
  
  // 最初の週の開始日までの空セルを追加
  const firstDay = parseISO(dateRange[0])         // 最初の日付をDate型に変換
  const firstDayOfWeek = getDay(firstDay)         // その日の曜日を取得（0=日曜日）
  for (let i = 0; i < firstDayOfWeek; i++) {
    currentWeek.push('')  // 空のセルで埋める
  }

  // すべての日付を週単位でグループ化
  dateRange.forEach((date) => {
    currentWeek.push(date)
    if (currentWeek.length === 7) {   // 1週間分のデータが集まったら
      weeks.push(currentWeek)         // weeksに追加し、
      currentWeek = []                // 新しい週を開始
    }
  })

  // 最後の週の残りを空セルで埋める
  if (currentWeek.length > 0) {
    while (currentWeek.length < 7) {
      currentWeek.push('')
    }
    weeks.push(currentWeek)
  }

  // 曜日ラベルの配列
  const weekDays = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat']

  return (
    // 最外部のコンテナ：幅いっぱいに広げて中央揃えにする
    <div className="w-full flex justify-center">
      {/* スクロール可能なコンテナ：スマートフォン表示時の横スクロールを管理 */}
      <div 
        ref={scrollContainerRef}
        className="max-w-full overflow-x-auto overflow-y-hidden pb-2"
      >
        {/* 最小幅を保証するコンテナ：スクロール時にコンテンツが縮まないようにする */}
        <div className="flex gap-1 min-w-min">
          {/* 曜日ラベルの列 */}
          <div className="flex flex-col justify-between pr-2 text-sm text-muted-foreground">
            {weekDays.map((day) => (
              <div key={day} className="h-3 flex items-center">
                {day}
              </div>
            ))}
          </div>

          {/* カレンダーグリッド：週ごとの列を表示 */}
          <div className="flex gap-1">
            {weeks.map((week, weekIndex) => (
              <div key={weekIndex} className="flex flex-col gap-1">
                {week.map((date, dayIndex) => {
                  // 空のセルの場合
                  if (!date) {
                    return <div key={`empty-${dayIndex}`} className="w-3 h-3" />
                  }

                  // その日のデータを検索（存在しない場合は count: 0 で作成）
                  const dayData = data.find((d) => d.date === date) || { date, count: 0 }
                  
                  // ツールチップ付きのセルを表示
                  return (
                    <TooltipProvider key={date}>
                      <Tooltip>
                        <TooltipTrigger asChild>
                          <div
                            className={`w-3 h-3 rounded-sm ${getColor(dayData.count)}`}
                            onMouseEnter={() => setHoveredDate(date)}
                            onMouseLeave={() => setHoveredDate(null)}
                          />
                        </TooltipTrigger>
                        <TooltipContent>
                          <p>{format(parseISO(date), 'MMM d, yyyy')}</p>
                          <p>{dayData.count} outputs</p>
                        </TooltipContent>
                      </Tooltip>
                    </TooltipProvider>
                  )
                })}
              </div>
            ))}
          </div>
        </div>
      </div>
    </div>
  )
}

================
File: components/HomePage.tsx
================
import Link from "next/link"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardFooter, CardHeader, CardTitle } from "@/components/ui/card"
import { ArrowRight, PenTool, List } from "lucide-react"

export default function HomePage() {
  return (
    <div className="min-h-screen">
      <div className="container mx-auto px-4 sm:px-6 lg:px-8 py-8 sm:py-12 lg:py-16">
        <header className="text-center mb-8 sm:mb-12 lg:mb-16">
          <h1 className="text-3xl sm:text-4xl lg:text-5xl font-bold mb-3 sm:mb-4">
            Web Developer&apos;s Output App
          </h1>
          <p className="text-base sm:text-lg lg:text-xl text-muted-foreground max-w-2xl mx-auto">
            記録し、分析し、成長する。あなたの学習をサポートします。
          </p>
        </header>

        <div className="grid grid-cols-1 md:grid-cols-2 gap-4 sm:gap-6 lg:gap-8 max-w-5xl mx-auto">
          <Card className="flex flex-col h-full">
            <CardHeader>
              <CardTitle className="flex items-center text-lg sm:text-xl lg:text-2xl">
                <PenTool className="mr-2 h-5 w-5 sm:h-6 sm:w-6" />
                新しいアウトプットを作成
              </CardTitle>
            </CardHeader>
            <CardContent className="flex-grow">
              <p className="text-sm sm:text-base lg:text-lg">
                あなたの学びを1分間でアウトプットしましょう。
                AIによる分析、修正、提案を受けることができます。
              </p>
            </CardContent>
            <CardFooter>
              <Button asChild size="lg" className="w-full">
                <Link href="/outputs/new">
                  始める <ArrowRight className="ml-2 h-4 w-4" />
                </Link>
              </Button>
            </CardFooter>
          </Card>

          <Card className="flex flex-col h-full">
            <CardHeader>
              <CardTitle className="flex items-center text-lg sm:text-xl lg:text-2xl">
                <List className="mr-2 h-5 w-5 sm:h-6 sm:w-6" />
                アウトプット一覧
              </CardTitle>
            </CardHeader>
            <CardContent className="flex-grow">
              <p className="text-sm sm:text-base lg:text-lg">
                これまでに作成したアウトプットを確認し、振り返ることができます。
                学習の進捗を可視化しましょう。
              </p>
            </CardContent>
            <CardFooter>
              <Button variant="outline" asChild size="lg" className="w-full">
                <Link href="/outputs">
                  一覧を見る <ArrowRight className="ml-2 h-4 w-4" />
                </Link>
              </Button>
            </CardFooter>
          </Card>
        </div>

        <footer className="mt-12 sm:mt-16 lg:mt-20 text-center text-xs sm:text-sm lg:text-base text-muted-foreground">
          <p>&copy; 2024 codev -Web Developer&apos;s Output App-. All rights reserved.</p>
        </footer>
      </div>
    </div>
  )
}

================
File: components/LandingPage.tsx
================
import Link from "next/link"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { ArrowRight, Code, BookOpen, Users, BrainCircuit, TrendingUp, Lightbulb, LucideIcon } from "lucide-react"

interface CardProps {
  icon: LucideIcon;
  title: string;
  description: string;
}

const FeatureCard = ({ icon: Icon, title, description }: CardProps) => (
  <Card>
    <CardHeader>
      <CardTitle className="flex items-center text-lg">
        <Icon className="mr-2 h-5 w-5" />
        {title}
      </CardTitle>
    </CardHeader>
    <CardContent>
      <p className="text-sm">{description}</p>
    </CardContent>
  </Card>
)

const OutputImportanceCard = ({ icon: Icon, title, description }: CardProps) => (
  <Card className="overflow-hidden">
    <CardHeader>
      <CardTitle className="flex items-center text-lg">
        <Icon className="mr-2 h-5 w-5" />
        {title}
      </CardTitle>
    </CardHeader>
    <CardContent>
      <p className="text-sm mb-4">{description}</p>
    </CardContent>
  </Card>
)

const TechStackItem = ({ name }: { name: string }) => (
  <div className="bg-primary text-primary-foreground rounded-full px-3 py-1 text-xs sm:text-sm font-medium">
    {name}
  </div>
)

export default function LandingPage() {
  const techStack = [
    "Next.js",
    "React",
    "TypeScript",
    "NextAuth.js",
    "Tailwind CSS",
    "shadcn/ui",
    "Prisma",
    "Vercel",
    "GPT-4-mini API",
    "Whisper API",
    "Qiita API",
  ]

  return (
    <div className="min-h-screen bg-gradient-to-b from-background to-secondary">
      <div className="container mx-auto px-4 sm:px-6 lg:px-8 py-8 sm:py-12 lg:py-16">
        <header className="text-center mb-12 sm:mb-16">
          <div className="flex justify-center items-center mb-4">
            <img src="/branding/logo.png" alt="codev" className="h-12 sm:h-16 mb-8 sm:mb-12"/>
          </div>
          <h1 className="text-3xl sm:text-3xl lg:text-5xl font-bold mb-4">Web Developer&apos;s Output App</h1>
          <p className="text-lg sm:text-xl text-muted-foreground mb-6 sm:mb-8">あなたの学びをアウトプットしよう。</p>
          <div className="flex flex-col sm:flex-row justify-center gap-4">
            <Button asChild size="lg" className="w-full sm:w-auto">
              <Link href="/login">ログイン</Link>
            </Button>
            <Button asChild variant="outline" size="lg" className="w-full sm:w-auto">
              <Link href="/signup">新規登録</Link>
            </Button>
          </div>
        </header>

        <section className="mb-12 sm:mb-16">
          <h2 className="text-2xl sm:text-3xl font-bold text-center mb-6 sm:mb-8">このアプリでできること</h2>
          <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-6 sm:gap-8">
            <FeatureCard
              icon={Code}
              title="学習のアウトプット"
              description="コーディングの経験や学んだことを、AI音声認識により簡単にアウトプットできます。"
            />
            <FeatureCard
              icon={BookOpen}
              title="AIによる分析"
              description="AIがあなたの学習内容を分析し、改善点や次のステップを提案します。"
            />
            <FeatureCard
              icon={Users}
              title="学習の記録"
              description="学習の記録を振り返りや復習に役立てることができます。"
            />
          </div>
        </section>

        <section className="mb-12 sm:mb-16">
          <h2 className="text-2xl sm:text-3xl font-bold text-center mb-6 sm:mb-8">なぜアウトプットが重要なのか？</h2>
          <div className="grid grid-cols-1 sm:grid-cols-2 gap-6 sm:gap-8">
            <OutputImportanceCard
              icon={BrainCircuit}
              title="知識の定着と理解の深化"
              description="学んだことを自分の言葉で表現することで、理解が深まり、長期記憶への転送が促進されます。"
            />
            <OutputImportanceCard
              icon={Lightbulb}
              title="思考の整理と知識の穴の発見"
              description="考えをまとめる過程で、概念間のつながりが明確になり、理解が不十分な部分が浮き彫りになります。"
            />
            <OutputImportanceCard
              icon={Users}
              title="フィードバックと新たな視点"
              description="アウトプットを共有することで、新たな視点や改善点を得られ、学習の質が向上します。"
            />
            <OutputImportanceCard
              icon={TrendingUp}
              title="モチベーション向上と継続的な成長"
              description="学習の進捗を可視化することで、継続的な学習意欲が高まり、長期的な成長につながります。"
            />
          </div>
        </section>

        <section className="mb-12 sm:mb-16">
          <h2 className="text-2xl sm:text-3xl font-bold text-center mb-6 sm:mb-8">使用技術</h2>
          <div className="flex flex-wrap justify-center gap-2 sm:gap-4">
            {techStack.map((tech, index) => (
              <TechStackItem key={index} name={tech} />
            ))}
          </div>
        </section>

        <div className="text-center">
          <h2 className="text-2xl sm:text-3xl font-bold mb-4">今すぐ始めよう</h2>
          <p className="text-base sm:text-lg text-muted-foreground mb-6 sm:mb-8">
            アウトプットを通じて、あなたの学習効率を最大化し、Web開発スキルを飛躍的に向上させましょう。
          </p>
          <Button asChild size="lg" className="w-full sm:w-auto">
            <Link href="/signup">
              無料で登録 <ArrowRight className="ml-2" />
            </Link>
          </Button>
        </div>
      </div>

      <footer className="bg-background py-6 sm:py-8">
        <div className="container mx-auto px-4 text-center text-sm text-muted-foreground">
          <p>&copy; 2024 codev -Web Developer&apos;s Output App-. All rights reserved.</p>
        </div>
      </footer>
    </div>
  )
}

================
File: components/LanguageSelect.tsx
================
"use client";

import React from "react";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";

const languages = [
  "HTML",
  "CSS",
  "Ruby",
  "Rails",
  "JavaScript",
  "TypeScript",
  "Next.js",
];

interface LanguageSelectProps {
  onLanguageChange: (language: string) => void;
}

const LanguageSelect: React.FC<LanguageSelectProps> = ({
  onLanguageChange,
}) => {
  return (
    <Select onValueChange={onLanguageChange}>
      <SelectTrigger>
        <SelectValue placeholder="勉強中の言語orフレームワークを選択" />
      </SelectTrigger>
      <SelectContent>
        {languages.map((lang) => (
          <SelectItem key={lang} value={lang}>
            {lang}
          </SelectItem>
        ))}
      </SelectContent>
    </Select>
  );
};

export default LanguageSelect;

================
File: components/learning-goals.tsx
================
'use client'

import { useState } from 'react'
import { LearningGoal } from '@prisma/client'
import { Checkbox } from '@/components/ui/checkbox'
import { Input } from '@/components/ui/input'
import { Button } from '@/components/ui/button'
import { toast } from '@/hooks/use-toast'

interface LearningGoalsProps {
  initialGoals: LearningGoal[]
  userId: string
}

export function LearningGoals({ initialGoals, userId }: LearningGoalsProps) {
  const [goals, setGoals] = useState(initialGoals)
  const [newGoalTitle, setNewGoalTitle] = useState('')

  const toggleGoalCompletion = async (goalId: string, completed: boolean) => {
    // 楽観的に UI を更新
    setGoals(goals.map(goal => 
      goal.id === goalId ? { ...goal, completed } : goal
    ))

    try {
      const response = await fetch(`/api/learning-goals/${goalId}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ completed }),
      })

      if (!response.ok) {
        throw new Error('Failed to update goal')
      }

      const updatedGoal = await response.json()
      
      toast({
        title: "目標を更新しました",
        description: `${updatedGoal.title} を ${completed ? '完了' : '未完了'} に設定しました。`,
      })
    } catch (error) {
      console.error('Error updating goal:', error)
      // エラーが発生した場合、状態を元に戻す
      setGoals(goals.map(goal => 
        goal.id === goalId ? { ...goal, completed: !completed } : goal
      ))
      toast({
        title: "エラー",
        description: "目標の更新に失敗しました。",
        variant: "destructive",
      })
    }
  }

  const addNewGoal = async () => {
    if (newGoalTitle.trim() === '') return

    // 楽観的に新しい目標を追加
    const optimisticGoal: LearningGoal = {
      id: Date.now().toString(), // 一時的なIDを生成
      title: newGoalTitle,
      description: '',
      completed: false,
      createdAt: new Date(),
      updatedAt: new Date(),
      userId: userId,
    }
    setGoals([...goals, optimisticGoal])
    setNewGoalTitle('')

    try {
      const response = await fetch('/api/learning-goals', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ title: newGoalTitle, userId }),
      })

      if (!response.ok) {
        throw new Error('Failed to add new goal')
      }

      const newGoal = await response.json()
      // 楽観的に追加した目標を実際のデータで置き換え
      setGoals(goals => goals.map(goal => 
        goal.id === optimisticGoal.id ? newGoal : goal
      ))
      
      toast({
        title: "新しい目標を追加しました",
        description: newGoal.title,
      })
    } catch (error) {
      console.error('Error adding new goal:', error)
      // エラーが発生した場合、楽観的に追加した目標を削除
      setGoals(goals => goals.filter(goal => goal.id !== optimisticGoal.id))
      toast({
        title: "エラー",
        description: "新しい目標の追加に失敗しました。",
        variant: "destructive",
      })
    }
  }

  return (
    <div className="space-y-4">
      {goals.map((goal) => (
        <div key={goal.id} className="flex items-center space-x-2">
          <Checkbox 
            id={goal.id} 
            checked={goal.completed}
            onCheckedChange={(checked) => toggleGoalCompletion(goal.id, checked as boolean)}
          />
          <label htmlFor={goal.id} className="text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70">
            {goal.title}
          </label>
        </div>
      ))}
      <div className="flex items-center space-x-2">
        <Input
          type="text"
          placeholder="新しい目標"
          value={newGoalTitle}
          onChange={(e) => setNewGoalTitle(e.target.value)}
        />
        <Button onClick={addNewGoal} aria-label="新しい目標を追加">追加</Button>
      </div>
    </div>
  )
}

================
File: components/navigation.tsx
================
"use client";

import { useEffect, useState } from "react";
import Link from "next/link";
import { usePathname } from "next/navigation";
import {
  NavigationMenu,
  NavigationMenuItem,
  NavigationMenuLink,
  NavigationMenuList,
} from "@/components/ui/navigation-menu";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { useSession, signOut } from "next-auth/react";
import { Session } from "next-auth";
import { ThemeToggle } from "./theme-toggle";
import { CodevLogo } from "@/components/logo";
import { Menu } from "lucide-react";
import { Button } from "@/components/ui/button";
import { Sheet, SheetContent, SheetTrigger } from "@/components/ui/sheet";

// ナビゲーションのスケルトンコンポーネント（変更なし）
function NavigationSkeleton() {
  return (
    <header className="border-b">
      <div className="container mx-auto px-4 py-2 flex justify-between items-center">
        <div className="w-1/3 h-8 bg-gray-200 rounded"></div>
        <div className="w-8 h-8 bg-gray-200 rounded-full"></div>
      </div>
    </header>
  );
}

// ユーザードロップダウンコンポーネント
function UserDropdown({ session, handleSignOut }: { session: Session; handleSignOut: () => void }) {
  const [isOpen, setIsOpen] = useState(false);

  return (
    <DropdownMenu open={isOpen} onOpenChange={setIsOpen}>
      <DropdownMenuTrigger className="focus:outline-none">
        <Avatar>
          <AvatarImage src="/avatar.png" alt={session?.user?.name || "ユーザー"} />
          <AvatarFallback>
            {session?.user?.name ? session.user.name[0].toUpperCase() : "U"}
          </AvatarFallback>
        </Avatar>
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end">
        <DropdownMenuItem asChild onSelect={() => setIsOpen(false)}>
          <Link href={`/users/${session.user.id}`} className="w-full">
            プロフィール
          </Link>
        </DropdownMenuItem>
        <DropdownMenuItem onSelect={() => {
          setIsOpen(false);
          handleSignOut();
        }}>
          ログアウト
        </DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}

// メインのナビゲーションコンポーネント
export default function Navigation({ serverSession }: { serverSession: Session | undefined }) {
  const pathname = usePathname();
  const { data: session, status } = useSession();
  const [mounted, setMounted] = useState(false);
  const [isSheetOpen, setIsSheetOpen] = useState(false);

  useEffect(() => {
    setMounted(true);
  }, []);

  useEffect(() => {
    console.log("セッションステータスが変更されました:", status, "セッション:", session || serverSession);
  }, [status, session, serverSession]);

  if (!mounted) {
    return <NavigationSkeleton />;
  }

  const handleSignOut = () => {
    signOut({ callbackUrl: '/' });
  };

  const currentSession = session || serverSession;

  // ナビゲーションメニュー項目
  const navItems = [
    { href: "/outputs/new", label: "新規アウトプット", requireAuth: true },
    { href: "/outputs", label: "アウトプット一覧", requireAuth: true }
  ];

  return (
    <header className="border-b">
      <div className="container mx-auto px-2 py-2 flex justify-between items-center">
        <div className="flex items-center">
          <CodevLogo />
          {/* デスクトップ用ナビゲーション */}
          <NavigationMenu className="hidden md:flex ml-4">
            <NavigationMenuList>
              {navItems.map((item) => (
                (currentSession) && (
                  <NavigationMenuItem key={item.href}>
                    <Link href={item.href} passHref legacyBehavior>
                      <NavigationMenuLink active={pathname.startsWith(item.href)}>
                        {item.label}
                      </NavigationMenuLink>
                    </Link>
                  </NavigationMenuItem>
                )
              ))}
            </NavigationMenuList>
          </NavigationMenu>
        </div>

        <div className="flex items-center space-x-2">
          <ThemeToggle />
          {currentSession?.user?.name ? (
            <>
              <span className="mr-2 text-sm font-medium hidden lg:inline-block">
                {currentSession.user.name} さんがログイン中
              </span>
              <UserDropdown session={currentSession} handleSignOut={handleSignOut} />
            </>
          ) : (
            <Link href="/login" className="text-sm font-medium">
              ログイン
            </Link>
          )}

          {/* モバイル用メニュー */}
          {currentSession && (
          <Sheet open={isSheetOpen} onOpenChange={setIsSheetOpen}>
            <SheetTrigger asChild>
              <Button variant="outline" size="icon" className="md:hidden">
                <Menu className="h-[1.2rem] w-[1.2rem]" />
                <span className="sr-only">メニュー</span>
              </Button>
            </SheetTrigger>
            <SheetContent side="right">
              <nav className="flex flex-col space-y-4">
                {navItems.map((item) => (
                  (!item.requireAuth || currentSession) && (
                    <Link
                      key={item.href}
                      href={item.href}
                      className={`text-lg ${pathname.startsWith(item.href) ? "font-bold" : ""}`}
                      onClick={() => setIsSheetOpen(false)}
                    >
                      {item.label}
                    </Link>
                  )
                ))}
              </nav>
            </SheetContent>
          </Sheet>
          )}
        </div>
      </div>
    </header>
  );
}

================
File: components/NewOutputForm.tsx
================
import React from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import LanguageSelect from "@/components/LanguageSelect";
import AudioRecorder from "@/components/AudioRecorder";

interface NewOutputFormProps {
  selectedLanguage: string;
  processingStage: string | null;
  onLanguageChange: (language: string) => void;
  onRecordingComplete: (audioFile: File) => Promise<void>;
}

const NewOutputForm: React.FC<NewOutputFormProps> = ({
  selectedLanguage,
  processingStage,
  onLanguageChange,
  onRecordingComplete,
}) => {
  return (
    <div className="container mx-auto px-4 py-8">
      <Card className="max-w-2xl mx-auto">
        <CardHeader>
          <CardTitle>新規アウトプット</CardTitle>
        </CardHeader>
        <CardContent className="space-y-4">
          <LanguageSelect onLanguageChange={onLanguageChange} />
          <AudioRecorder
            onRecordingComplete={onRecordingComplete}
            isDisabled={!selectedLanguage || !!processingStage}
          />
          {processingStage && <p>{processingStage}...</p>}
        </CardContent>
      </Card>
    </div>
  );
};

export default NewOutputForm;

================
File: components/output-analytics.tsx
================
"use client"

import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer } from 'recharts'

interface OutputAnalyticsProps {
  data: { date: string; count: number }[]
}

export function OutputAnalytics({ data }: OutputAnalyticsProps) {

  
  return (
    <ResponsiveContainer width="100%" height={300}>
      <LineChart data={data}>
        <CartesianGrid strokeDasharray="3 3" />
        <XAxis dataKey="date" />
        <YAxis />
        <Tooltip />
        <Line type="monotone" dataKey="count" stroke="#8884d8" activeDot={{ r: 8 }} />
      </LineChart>
    </ResponsiveContainer>
  )
}

================
File: components/output-list.tsx
================
import Link from 'next/link'
import { Output } from '@prisma/client'
import { Card, CardHeader, CardTitle, CardContent } from '@/components/ui/card'
import { Badge } from '@/components/ui/badge'

interface OutputListProps {
  outputs: Output[]
}

export function OutputList({ outputs }: OutputListProps) {
  return (
    <div className="space-y-4">
      {outputs.map((output) => (
        <Card key={output.id}>
          <Link href={`/outputs/${output.id}`}>
            <CardHeader>
              <CardTitle>{output.title}</CardTitle>
            </CardHeader>
            <CardContent>
              <Badge>{output.language}</Badge>
              <p className="mt-2 text-sm text-gray-500">{output.createdAt.toLocaleString()}</p>
            </CardContent>
          </Link>
        </Card>
      ))}
    </div>
  )
}

================
File: components/OutputDetailPreview.tsx
================
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Separator } from "@/components/ui/separator"
import { Badge } from "@/components/ui/badge"
import { ExternalLink } from "lucide-react"
import { Output, RelatedLink } from "@prisma/client"
import { Button } from "./ui/button"
import Link from "next/link"

const formatMarkdown = (text: string) => {
  return text
    .replace(/\n/g, '<br>')
    .replace(/##\s(.*)/g, '<h2 class="text-xl font-semibold mt-2 mb-1">$1</h2>')
    .replace(/\*(.*?)\*/g, '<em>$1</em>')
}


type OutputWithRelatedLinks = Output & {
  relatedLinks: RelatedLink[];
};

interface OutputDetailPreviewProps {
  output: OutputWithRelatedLinks;
}

export default function Component({ output }: OutputDetailPreviewProps) {
  return (
    <div className="container mx-auto px-4 py-8">
      <div className="grid grid-cols-1 md:grid-cols-2 gap-8">
        <Card>
          <CardHeader>
            <CardTitle>Original Text</CardTitle>
          </CardHeader>
          <CardContent>
            <p>{output.originalContent}</p>
          </CardContent>
        </Card>
        <Card>
          <CardHeader>
            <CardTitle>Corrected Text</CardTitle>
          </CardHeader>
          <CardContent>
            <p>{output.correctedContent}</p>
          </CardContent>
        </Card>
      </div>
      <Separator className="my-8" />
      <Card>
        <CardHeader>
          <CardTitle>Analysis</CardTitle>
        </CardHeader>
        <CardContent>
          <p className="mb-4">{output.analysis}</p>
          <div className="space-y-4">
            <div className="flex items-center justify-between">
              <h3 className="text-lg font-semibold">Related Links</h3>
              <Badge>{output.language}</Badge>
            </div>
            {output.relatedLinks.map((link, index) => (
              <div key={index} className="flex flex-col space-y-2">
                <div className="flex items-center space-x-2">
                  <Badge variant={link.isOfficial ? "default" : "secondary"}>
                    {link.isOfficial ? "Official" : "Community"}
                  </Badge>
                  <a
                    href={link.url}
                    target="_blank"
                    rel="noopener noreferrer"
                    className="text-blue-500 hover:underline flex items-center"
                  >
                    {link.siteName}
                    <ExternalLink className="ml-1 h-4 w-4" />
                  </a>
                </div>
                <div className="text-sm text-gray-600">
                  {formatMarkdown(link.summary)}
                </div>
                {!link.isOfficial && (
                  <p className="text-xs text-gray-400">Likes: {link.likes_count}</p>
                )}
              </div>
            ))}
          </div>
        </CardContent>
      </Card>

      <Button asChild
        size="lg"
        className="fixed bottom-8 right-8 rounded-full shadow-lg"
      >
        <Link href="/outputs">
          Output一覧に戻る
        </Link>
      </Button>

    </div>
  )
}

================
File: components/OutputListReview.tsx
================
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Badge } from "@/components/ui/badge"
import { Button } from "@/components/ui/button"
import { PlusCircle } from "lucide-react"
import Link from "next/link";
import { Output } from "@prisma/client";

export default function Component({ outputs }: { outputs: Output[] }) {
  return (
    <div className="container mx-auto px-4 py-8">
      {outputs.length === 0 ? (
        <div className="text-center py-8 px-8">
          <p className="text-xl">まだOutputがありません。右下のボタンから新規アウトプットを作成しましょう。</p>
        </div>
      ) : (
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
          {outputs.map((output) => (
            <Card key={output.id}>
              <Link href={`/outputs/${output.id}`}>
                <CardHeader>
                  <CardTitle>{output.title}</CardTitle>
                </CardHeader>
                <CardContent>
                  <Badge>{output.language}</Badge>
                  <p className="mt-2 text-sm text-gray-500">{output.createdAt.toLocaleString()}</p>
                </CardContent>
              </Link>
            </Card>
          ))}
        </div>
      )}
      <Button asChild
        size="lg"
        className="fixed bottom-8 right-8 rounded-full shadow-lg"
      >
        <Link href="/outputs/new">
          <PlusCircle className="mr-2 h-4 w-4" /> 新規アウトプット
        </Link>
      </Button>
    </div>
  )
}

================
File: components/providers.tsx
================
"use client";

import { SessionProvider } from "next-auth/react";
import { ReactNode } from "react";
import { Session } from "next-auth";

export function Providers({ children, session }: { children: ReactNode; session: Session | null }) {
  return <SessionProvider session={session}>{children}</SessionProvider>;
}

================
File: components/skill-tags.tsx
================
import { Badge } from '@/components/ui/badge'

interface SkillTagsProps {
  skills: string[]
}

export function SkillTags({ skills }: SkillTagsProps) {
  return (
    <div className="flex flex-wrap gap-2">
      {skills.map((skill, index) => (
        <Badge key={index} variant="secondary">{skill}</Badge>
      ))}
    </div>
  )
}

================
File: components/theme-provider.tsx
================
"use client"

import * as React from "react"
import { ThemeProvider as NextThemesProvider } from "next-themes"
import { type ThemeProviderProps } from "next-themes/dist/types"

export function ThemeProvider({ children, ...props }: ThemeProviderProps) {
  return <NextThemesProvider {...props}>{children}</NextThemesProvider>
}

================
File: components/theme-toggle.tsx
================
'use client'

import { Moon, Sun } from "lucide-react"
import { useTheme } from "next-themes"
import { Button } from "@/components/ui/button"

export function ThemeToggle() {
  const { theme, setTheme } = useTheme()

  return (
    <Button
      variant="ghost"
      size="icon"
      onClick={() => setTheme(theme === "light" ? "dark" : "light")}
    >
      <Sun className="h-[1.2rem] w-[1.2rem] rotate-0 scale-100 transition-all dark:-rotate-90 dark:scale-0" />
      <Moon className="absolute h-[1.2rem] w-[1.2rem] rotate-90 scale-0 transition-all dark:rotate-0 dark:scale-100" />
      <span className="sr-only">Toggle theme</span>
    </Button>
  )
}

================
File: components/web-vitals-reporter.tsx
================
'use client'

import { useReportWebVitals } from 'next/web-vitals'

export function WebVitalsReporter() {
  useReportWebVitals((metric) => {
    console.log(metric)
    // ここで必要に応じて分析サービスにデータを送信
  })

  return null
}

================
File: hooks/use-toast.ts
================
"use client"

// Inspired by react-hot-toast library
import * as React from "react"

import type {
  ToastActionElement,
  ToastProps,
} from "@/components/ui/toast"

const TOAST_LIMIT = 1
const TOAST_REMOVE_DELAY = 1000000

type ToasterToast = ToastProps & {
  id: string
  title?: React.ReactNode
  description?: React.ReactNode
  action?: ToastActionElement
}

const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
} as const

let count = 0

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER
  return count.toString()
}

type ActionType = typeof actionTypes

type Action =
  | {
      type: ActionType["ADD_TOAST"]
      toast: ToasterToast
    }
  | {
      type: ActionType["UPDATE_TOAST"]
      toast: Partial<ToasterToast>
    }
  | {
      type: ActionType["DISMISS_TOAST"]
      toastId?: ToasterToast["id"]
    }
  | {
      type: ActionType["REMOVE_TOAST"]
      toastId?: ToasterToast["id"]
    }

interface State {
  toasts: ToasterToast[]
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId)
    dispatch({
      type: "REMOVE_TOAST",
      toastId: toastId,
    })
  }, TOAST_REMOVE_DELAY)

  toastTimeouts.set(toastId, timeout)
}

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      }

    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t
        ),
      }

    case "DISMISS_TOAST": {
      const { toastId } = action

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId)
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id)
        })
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t
        ),
      }
    }
    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        }
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      }
  }
}

const listeners: Array<(state: State) => void> = []

let memoryState: State = { toasts: [] }

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action)
  listeners.forEach((listener) => {
    listener(memoryState)
  })
}

type Toast = Omit<ToasterToast, "id">

function toast({ ...props }: Toast) {
  const id = genId()

  const update = (props: ToasterToast) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    })
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id })

  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss()
      },
    },
  })

  return {
    id: id,
    dismiss,
    update,
  }
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState)

  React.useEffect(() => {
    listeners.push(setState)
    return () => {
      const index = listeners.indexOf(setState)
      if (index > -1) {
        listeners.splice(index, 1)
      }
    }
  }, [state])

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
  }
}

export { useToast, toast }

================
File: lib/auth/auth-options.ts
================
import { authProviders } from "./providers";
import { callbacks } from "./callbacks";

import { NextAuthOptions } from "next-auth";
import { PrismaAdapter } from "@next-auth/prisma-adapter";
import { PrismaClient } from "@prisma/client";
import bcrypt from "bcryptjs";




const prisma = new PrismaClient();

//ユーザーのサインアップ
export async function signUp({ email, password, name }: { email: string; password: string; name: string }) {
  
  // メールアドレス重複確認
  const existingUser = await prisma.user.findUnique({
    where: { email },
  });

  if (existingUser) {
    throw new Error("このメールアドレスは既に使用されています。");
  }

  // パスワードハッシュ化
  const hashedPassword = await bcrypt.hash(password, 10);

  // ユーザー作成
  const user = await prisma.user.create({
    data: {
      email,
      name,
      password: hashedPassword,
    },
  });

  // ユーザー情報を返す
  return { id: user.id, email: user.email, name: user.name };
}

//NextAuth.jsの設定オブジェクト。認証システムの動作を定義している。
export const authOptions: NextAuthOptions = {
  adapter: PrismaAdapter(prisma),
  providers: [authProviders],
  callbacks,
  pages: {
    signIn: "/login",
  },
  session: {
    strategy: "jwt",
  },
  secret: process.env.NEXTAUTH_SECRET,
};

================
File: lib/auth/callbacks.ts
================
import { CallbacksOptions } from "next-auth";


export const callbacks:Partial<CallbacksOptions> = {
  //jwtトークンの作成
  async jwt({ token, user }) {
    if (user) {
      token.id = user.id;
    }
    return token;
  },
  //セッションの作成
  async session({ session, token }) {
    if (session.user) {
      session.user.id = token.id as string;
    }
    return session;
  },
  //ログイン後のリダイレクト先を指定
  async redirect({ url, baseUrl }) {
    if (url.startsWith(baseUrl)) {
      return `${baseUrl}/home`;
    } else if (url.startsWith("/")) {
      return `${baseUrl}/home`;
    }
    return `${baseUrl}/home`;
  },
};

================
File: lib/auth/providers.ts
================
import CredentialsProvider from "next-auth/providers/credentials";
import { prisma } from "@/lib/prisma";
import bcrypt from "bcryptjs";

export const authProviders = CredentialsProvider({
  name: "Credentials",
  credentials: {
    email: { label: "Email", type: "text" },
    password: { label: "Password", type: "password" },
  },
  //ユーザーの認証ロジック
  async authorize(credentials) {
    if (!credentials?.email || !credentials?.password) {
      throw new Error("メールアドレスとパスワードを入力してください");
    }
    const user = await prisma.user.findUnique({
      where: { email: credentials.email },
    });
    if (!user) {
      throw new Error("ユーザーが見つかりません");
    }
    const isPasswordValid = await bcrypt.compare(
      credentials.password,
      user.password
    );
    if (!isPasswordValid) {
      throw new Error("パスワードが正しくありません");
    }
    return { id: user.id, email: user.email, name: user.name };
  },
});

================
File: lib/api.ts
================
import { prisma } from "./prisma";
import { differenceInDays } from "date-fns";
import { LearningGoal } from '@prisma/client'

interface Output {
  id: string;
  createdAt: Date;
  updatedAt: Date;
  title: string;
  originalContent: string;
  correctedContent: string;
  analysis: string;
  language: string;
  userId: string;
}

interface UserProfile {
  id: string;
  name: string | null;
  email: string;
  createdAt: Date;
  todayOutputs: number;
  totalOutputs: number;
  currentStreak: number;
  recentOutputs: Output[];
  learningGoals: LearningGoal[];
  outputCalendar: Record<string, number>;
  outputs: Output[];
}

export async function getUserProfile(userId: string): Promise<UserProfile | null> {
  try {
    const user = await prisma.user.findUnique({
      where: { id: userId },
      include: {
        outputs: {
          orderBy: { createdAt: 'desc' },
          take: 5, // 最新の5つのアウトプットを取得
        },
        learningGoals: true,
      },
    });

    if (!user) {
      throw new Error("ユーザーが見つかりません");
    }

    const today = new Date();
    today.setHours(0, 0, 0, 0);

    const todayOutputs = user.outputs.filter(output => 
      output.createdAt >= today
    ).length;

    const totalOutputs = user.outputs.length;

    // 現在のストリークを計算
    let currentStreak = 0;
    let lastOutputDate = new Date(0);
    for (const output of user.outputs) {
      if (differenceInDays(output.createdAt, lastOutputDate) <= 1) {
        currentStreak++;
        lastOutputDate = output.createdAt;
      } else {
        break;
      }
    }

    // アウトプットカレンダーデータの作成
    const outputCalendar = user.outputs.reduce((acc, output) => {
      const date = output.createdAt.toISOString().split('T')[0];
      acc[date] = (acc[date] || 0) + 1;
      return acc;
    }, {} as Record<string, number>);

    return {
      id: user.id,
      name: user.name,
      email: user.email,
      createdAt: user.createdAt,
      todayOutputs,
      totalOutputs,
      currentStreak,
      recentOutputs: user.outputs,
      learningGoals: user.learningGoals,
      outputCalendar,
      outputs: user.outputs, // outputs プロパティを追加
    };
  } catch (error) {
    console.error("ユーザープロファイルの取得中にエラーが発生しました:", error);
    throw new Error("ユーザープロファイルの取得に失敗しました");
  }
}

================
File: lib/db.ts
================
import { PrismaClient } from "@prisma/client";
import { PrismaClientKnownRequestError } from "@prisma/client/runtime/library";


const prisma = new PrismaClient();

export async function saveOutput(
  title: string,
  originalContent: string,
  correctedContent: string,
  analysis: string,
  relatedLinks: Array<{
    siteName: string;
    url: string;
    summary: string;
    likes_count: number;
    isOfficial: boolean;
  }>,
  userId: string,
  language: string
) {
  try {
    const output = await prisma.output.create({
      data: {
        title,
        originalContent,
        correctedContent,
        analysis,
        relatedLinks: {
          create: relatedLinks.map((link) => ({
            siteName: link.siteName,
            url: link.url,
            summary: link.summary,
            likes_count: link.likes_count, // undefined の場合は Prisma が null として扱います
            isOfficial: link.isOfficial,
          })),
        },
        userId: userId,
        language: language,
      },
      include: {
        relatedLinks: true,
      },
    });
    return output;
  } catch (error) {
    console.error("Error saving output:", error);
    if (error instanceof PrismaClientKnownRequestError) {
      if (error.code === 'P2003') {
        throw new Error(`User with ID ${userId} not found`);
      }
    }
    throw error;
  }
}

export async function getOutputs(userId: string) {
  try {
    const outputs = await prisma.output.findMany({
      where: {
        userId,
      },
      orderBy: {
        createdAt: "desc",
      },
    });
    return outputs;
  } catch (error) {
    console.error("Error fetching outputs:", error);
    throw error;
  }
}

export async function getOutputById(id: string) {
  try {
    return prisma.output.findUnique({
      where: { id },
      include: { relatedLinks: true },
    });
  } catch (error) {
    console.error("Error fetching output:", error);
    throw error;
  }
}

================
File: lib/gptAnalysis.ts
================
import OpenAI from "openai";
import { z } from "zod";
import axios from "axios";
import { zodResponseFormat } from "openai/helpers/zod";

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

const OfficialDocLink = z.object({
  siteName: z.string(),
  url: z.string(),
  summary: z.string(),
  isOfficial: z.literal(true),
});

const QiitaArticleLink = z.object({
  siteName: z.string(),
  url: z.string(),
  summary: z.string(),
  likes_count: z.number(),
  isOfficial: z.literal(false),
});

// eslint-disable-next-line @typescript-eslint/no-unused-vars
const RelatedLink = z.union([OfficialDocLink, QiitaArticleLink]);

const AnalysisResult = z.object({
  title: z.string(),
  correctedText: z.string(),
  analysis: z.string(),
  keywords: z.array(z.string()),
  officialDocs: z.array(OfficialDocLink),
});

type QiitaArticleLinkType = z.infer<typeof QiitaArticleLink>;
type RelatedLinkType = z.infer<typeof RelatedLink>;

interface QiitaArticle {
  title: string;
  url: string;
  body: string;
  likes_count: number;
}

async function getQiitaArticles(
  initialKeywords: string[],
  language: string,
  limit: number = 2
): Promise<QiitaArticleLinkType[]> {
  async function searchQiita(
    keywords: string[],
    useTag: boolean
  ): Promise<QiitaArticle[]> {
    const query = useTag
      ? `title:${keywords.join("+")} tag:${language}`
      : `title:${keywords.join("+")}`;
    console.log(`Searching with query: ${query}`);

    const response = await axios.get<QiitaArticle[]>(
      `https://qiita.com/api/v2/items`,
      {
        params: {
          query: query,
          per_page: 20,
          page: 1,
        },
        headers: {
          Authorization: `Bearer ${process.env.QIITA_ACCESS_TOKEN}`,
        },
      }
    );

    console.log(`Found ${response.data.length} articles`);
    return response.data;
  }

  try {
    const keywords = [...initialKeywords];
    let articles: QiitaArticle[] = [];

    // タグ付きで検索
    articles = await searchQiita(keywords, true);

    // タグなしで検索
    if (articles.length === 0) {
      articles = await searchQiita(keywords, false);
    }

    // キーワードを減らしながら検索
    while (articles.length === 0 && keywords.length > 1) {
      keywords.pop();
      console.log(`Reducing keywords to: ${keywords.join(", ")}`);
      articles = await searchQiita(keywords, false);
    }

    if (articles.length === 0 && keywords.length === 0) {
      console.log("No articles found after all attempts");
      return [];
    }

    return articles
      .sort(
        (a: { likes_count: number }, b: { likes_count: number }) =>
          b.likes_count - a.likes_count
      )
      .slice(0, limit)
      .map((article: QiitaArticle) => ({
        siteName: article.title,
        url: article.url,
        summary:
          article.body.length > 100
            ? article.body.substring(0, 97) + "..."
            : article.body,
        likes_count: article.likes_count,
        isOfficial: false,
      }));
  } catch (error) {
    console.error("Error fetching Qiita articles:", error);
    return [];
  }
}

export async function analyzeAndCorrectWithGPT(
  content: string,
  language: string
) {
  try {
    const completion = await openai.beta.chat.completions.parse({
      model: "gpt-4o-mini-2024-07-18",
      messages: [
        {
          role: "system",
          content: `
            You are a web development expert. Analyze the text provided by a web development beginner in Japan, which has been transcribed through speech recognition.
            Your task is to correct any speech recognition errors, analyze the content, and provide relevant official documentation links shown below "Resources for Documentation Links". Check the link whether it has expired or not.
            When giving feedback, praise what the beginner has learned and explain the analysis gently.
            - **Resources for Documentation Links:**
              - HTML, CSS, JavaScript: MDN web docs (https://developer.mozilla.org/ja/)
              - Ruby: Ruby公式リファレンス (https://docs.ruby-lang.org/ja/3.3/doc/)
              - Rails: Ruby on Railsガイド (https://railsguides.jp/)
              - TypeScript: TypeScript Documentation (https://www.typescriptlang.org/docs/)
              - Next.js: 公式ドキュメント (https://nextjs.org/docs/)

            # Steps

            1. **Correct Speech Recognition Errors:** 
              - Review the provided web development beginner's outputs and correct any errors caused by speech recognition inaccuracies.
              - Put into ”correctedText”.
            
            2. **Analyze Content:**
              - Extract key points and provide explanations for technical terms within the corrected text.
              - Highlight the learner's achievements and provide gentle explanations and any Tips for the beginner.
              - Put into "analysis"

            3. **Provide Related Keywords and Links:**
              - Identify 3 keywords from your "analysis" results that can be used to search related documents using the QiitaAPI.
              - Provide one related official documentation links containing:
                - siteName: The name of the site.
                - url: The URL of the site. Suggest a link to the official ${language}'s reference. Actively suggest its child pages. Do not put on the expired link.
                - summary: A brief summary of the content (within 100 characters).
                - isOfficial: Indicate if it's an official document.

            # Output Format

              json
              {
                "title": "Make the title of this output based on your correctedText",
                "correctedText": "Corrected version of the text in Japanese",
                "analysis": "Explanation of key points and terms from the corrected text in Japanese",
                "keywords": ["keyword1", "keyword2"], // pick up from "analysis"
                "RelatedLink": [
                  {
                    "siteName": "Site Name 1",
                    "url": "https://...",
                    "summary": "Brief summary",
                    "isOfficial": true
                  }
                ]
              }
            `,
        },
        {
          role: "user",
          content: `\n\n${content}\n\n`,
        },
      ],
      response_format: zodResponseFormat(AnalysisResult, "analysis_result"),
      max_tokens: 1000,
    });

    const result = completion.choices[0].message.parsed;

    if (!result) {
      throw new Error("GPTの分析結果が空です");
    }

    console.log("GPT Response:", JSON.stringify(result, null, 2));

    // Qiita記事の取得
    const qiitaArticles = await getQiitaArticles(result.keywords, language);
    console.log("Qiita Articles: ", qiitaArticles);

    const relatedLinks: RelatedLinkType[] = [
      ...result.officialDocs,
      ...qiitaArticles,
    ];

    return {
      ...result,
      relatedLinks,
    };
  } catch (error) {
    console.error("GPTでの分析中にエラーが発生しました:", error);
    throw new Error("出力の分析と修正に失敗しました");
  }
}

================
File: lib/prisma.ts
================
import { PrismaClient } from "@prisma/client";

const prismaClientSingleton = () => {
  return new PrismaClient();
};

type PrismaClientSingleton = ReturnType<typeof prismaClientSingleton>;

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClientSingleton | undefined;
};

export const prisma = globalForPrisma.prisma ?? prismaClientSingleton();

if (process.env.NODE_ENV !== "production") globalForPrisma.prisma = prisma;

================
File: lib/qiita.ts
================
import axios from "axios";

interface QiitaArticle {
  title: string;
  url: string;
  created_at: string;
  user: {
    name: string;
  };
}

export async function getRelatedQiitaArticles(
  keyword: string
): Promise<QiitaArticle[]> {
  try {
    const response = await axios.get(
      `https://qiita.com/api/v2/items?query=${encodeURIComponent(
        keyword
      )}&per_page=5`,
      {
        headers: {
          Authorization: `Bearer ${process.env.QIITA_ACCESS_TOKEN}`,
        },
      }
    );

    return response.data as QiitaArticle[];
  } catch (error) {
    console.error("Qiita記事の取得中にエラーが発生しました:", error);
    throw new Error("Qiita記事の取得に失敗しました");
  }
}

================
File: lib/utils.ts
================
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

================
File: lib/whisper.ts
================
import OpenAI from "openai";

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
  timeout: 30000, // タイムアウトを30秒に設定
});

export async function transcribeAudio(audioFile: File): Promise<string> {
  try {

    // FileをNodeのReadableStreamに変換
    const buffer = Buffer.from(await audioFile.arrayBuffer());

    // OpenAI APIに送信するファイル形式を明示的に指定
    const file = new File([buffer], "audio.mp4", { 
      type: audioFile.type 
    });

    console.log("Sending file to OpenAI:", {
      filename: file.name,
      type: file.type,
      size: file.size
    });
   
    const transcription = await openai.audio.transcriptions.create({
      file: audioFile,
      model: "whisper-1",
      language: "ja",
    });

    return transcription.text;
  } catch (error) {
    console.error("Error transcribing audio:", error);
    // エラーの詳細をログに出力
    if (error instanceof OpenAI.APIError) {
      console.error("OpenAI API error details:", {
        status: error.status,
        message: error.message,
        code: error.code,
        type: error.type
      });
    }
    throw error;
  }
}

================
File: prisma/migrations/20241014070124_init/migration.sql
================
-- CreateTable
CREATE TABLE "User" (
    "id" TEXT NOT NULL,
    "name" TEXT,
    "email" TEXT NOT NULL,
    "password" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "User_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Output" (
    "id" TEXT NOT NULL,
    "title" TEXT NOT NULL,
    "originalContent" TEXT NOT NULL,
    "correctedContent" TEXT NOT NULL,
    "analysis" TEXT NOT NULL,
    "language" TEXT NOT NULL,
    "userId" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "Output_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "RelatedLink" (
    "id" TEXT NOT NULL,
    "siteName" TEXT NOT NULL,
    "url" TEXT NOT NULL,
    "summary" TEXT NOT NULL,
    "likes_count" INTEGER,
    "isOfficial" BOOLEAN NOT NULL,
    "outputId" TEXT NOT NULL,

    CONSTRAINT "RelatedLink_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "User_email_key" ON "User"("email");

-- AddForeignKey
ALTER TABLE "Output" ADD CONSTRAINT "Output_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "RelatedLink" ADD CONSTRAINT "RelatedLink_outputId_fkey" FOREIGN KEY ("outputId") REFERENCES "Output"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

================
File: prisma/migrations/20241020161545_add_learning_goals/migration.sql
================
-- CreateTable
CREATE TABLE "LearningGoal" (
    "id" TEXT NOT NULL,
    "title" TEXT NOT NULL,
    "description" TEXT NOT NULL,
    "completed" BOOLEAN NOT NULL DEFAULT false,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "userId" TEXT NOT NULL,

    CONSTRAINT "LearningGoal_pkey" PRIMARY KEY ("id")
);

-- AddForeignKey
ALTER TABLE "LearningGoal" ADD CONSTRAINT "LearningGoal_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

================
File: prisma/migrations/migration_lock.toml
================
# Please do not edit this file manually
# It should be added in your version-control system (i.e. Git)
provider = "postgresql"

================
File: prisma/schema.prisma
================
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("POSTGRES_PRISMA_URL")
  directUrl = env("POSTGRES_URL_NON_POOLING")
}

model User {
  id             String          @id @default(cuid())
  name           String?
  email          String          @unique
  password       String
  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt
  outputs        Output[]
  learningGoals  LearningGoal[]
}

model Output {
  id               String        @id @default(cuid())
  title            String
  originalContent  String
  correctedContent String
  analysis         String
  language         String
  userId           String
  createdAt        DateTime      @default(now())
  updatedAt        DateTime      @updatedAt
  user             User          @relation(fields: [userId], references: [id])
  relatedLinks     RelatedLink[]
}

model RelatedLink {
  id          String  @id @default(cuid())
  siteName    String
  url         String
  summary     String
  likes_count Int?
  isOfficial  Boolean
  outputId    String
  output      Output  @relation(fields: [outputId], references: [id])
}

model LearningGoal {
  id          String   @id @default(cuid())
  title       String
  description String
  completed   Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  userId      String
  user        User     @relation(fields: [userId], references: [id])
}

================
File: public/branding/favicon.svg
================
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 60 60">
  <defs>
    <linearGradient id="gradient" x1="0%" y1="0%" x2="100%" y2="0%">
      <stop offset="0%" style="stop-color:#3B82F6"/>
      <stop offset="100%" style="stop-color:#8B5CF6"/>
    </linearGradient>
  </defs>
  
  <path 
    d="M10 15 L25 30 L10 45" 
    fill="none" 
    stroke="url(#gradient)" 
    stroke-width="4" 
    stroke-linecap="round" 
    stroke-linejoin="round"
  />
  
  <path d="M35 25 Q40 30 35 35" fill="none" stroke="url(#gradient)" stroke-width="3.5" stroke-linecap="round"/>
  <path d="M40 20 Q47 30 40 40" fill="none" stroke="url(#gradient)" stroke-width="3.5" stroke-linecap="round"/>
  <path d="M45 15 Q55 30 45 45" fill="none" stroke="url(#gradient)" stroke-width="3.5" stroke-linecap="round"/>
  
</svg>

================
File: scripts/create-test-user.ts
================
//test用のユーザーを作成するスクリプト

import { PrismaClient } from "@prisma/client";
import bcrypt from "bcryptjs";

const prisma = new PrismaClient();

async function main() {
  const email = "test@example.com";
  const password = "testpassword123";
  const name = "Test User";

  const hashedPassword = await bcrypt.hash(password, 10);

  const user = await prisma.user.upsert({
    where: { email: email },
    update: {},
    create: {
      email: email,
      name: name,
      password: hashedPassword,
    },
  });

  console.log(`User created/updated: ${user.email}`);
}

main()
  .catch((e) => console.error(e))
  .finally(async () => await prisma.$disconnect());

================
File: types/next-auth.d.ts
================
import NextAuth from "next-auth";

declare module "next-auth" {
  interface Session extends DefaultSession {
    user: {
      id: string;
      name?: string | null;
      email?: string | null;
      image?: string | null;
    } & DefaultSession["user"]
  }

  interface User {
    id: string;
    name?: string | null;
    email?: string | null;
    image?: string | null;
  }
}

declare module "next-auth/jwt" {
  interface JWT {
    id: string;
  }
}

================
File: .eslintrc.json
================
{
  "extends": ["next/core-web-vitals", "next/typescript"]
}

================
File: .gitignore
================
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js
.yarn/install-state.gz

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# local env files
.env
.env*.local
.env*.production


# vercel
.vercel

# typescript
*.tsbuildinfo

================
File: babel.config.js
================
module.exports = {
  presets: ['next/babel'],
}

================
File: components.json
================
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "default",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.ts",
    "css": "app/globals.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  }
}

================
File: env.d.ts
================
declare namespace NodeJS {
  interface ProcessEnv {
    NEXTAUTH_SECRET: string;
    NEXTAUTH_URL: string;
    OPENAI_API_KEY: string;
    POSTGRES_DATABASE: string;
    POSTGRES_HOST: string;
    POSTGRES_PASSWORD: string;
    POSTGRES_PRISMA_URL: string;
    POSTGRES_URL: string;
    POSTGRES_URL_NON_POOLING: string;
    POSTGRES_URL_NO_SSL: string;
    POSTGRES_USER: string;
    QIITA_ACCESS_TOKEN: string;
    DEV_SERVER_URL: string;
    TEST_USER_EMAIL: string;
    TEST_USER_PASSWORD: string;
  }
}

================
File: global.d.ts
================
import '@testing-library/jest-dom/extend-expect'

================
File: jest.config.js
================
const nextJest = require('next/jest')

const createJestConfig = nextJest({
  dir: './',
})

const customJestConfig = {
  setupFilesAfterEnv: ['<rootDir>/jest.setup.js'],
  testEnvironment: 'jest-environment-jsdom',
  testPathIgnorePatterns: ['<rootDir>/.next/', '<rootDir>/node_modules/'],
  moduleNameMapper: {
    '^@/components/(.*)$': '<rootDir>/components/$1',
    '^@/pages/(.*)$': '<rootDir>/pages/$1',
  },
  transform: {
    '^.+\\.(js|jsx|ts|tsx)$': ['babel-jest', { presets: ['next/babel'] }],
  },
}

module.exports = createJestConfig(customJestConfig)

================
File: jest.setup.js
================
import '@testing-library/jest-dom'

================
File: next-env.d.ts
================
/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/building-your-application/configuring/typescript for more information.

================
File: next.config.mjs
================
/** @type {import('next').NextConfig} */
const nextConfig = {
  experimental: {
    webVitalsAttribution: ['CLS', 'LCP'],
  },
};

export default nextConfig;

================
File: package.json
================
{
  "name": "web-dev-output-app",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "prisma generate && next build",
    "start": "next start",
    "lint": "next lint",
    "create-test-user": "ts-node -P tsconfig-scripts.json scripts/create-test-user.ts",
    "test": "jest --watchAll"
  },
  "dependencies": {
    "@hookform/resolvers": "^3.9.0",
    "@next-auth/prisma-adapter": "^1.0.7",
    "@prisma/client": "^5.20.0",
    "@radix-ui/react-avatar": "^1.1.1",
    "@radix-ui/react-checkbox": "^1.1.2",
    "@radix-ui/react-dialog": "^1.1.2",
    "@radix-ui/react-dropdown-menu": "^2.1.2",
    "@radix-ui/react-label": "^2.1.0",
    "@radix-ui/react-navigation-menu": "^1.2.1",
    "@radix-ui/react-progress": "^1.1.0",
    "@radix-ui/react-select": "^2.1.2",
    "@radix-ui/react-separator": "^1.1.0",
    "@radix-ui/react-slot": "^1.1.0",
    "@radix-ui/react-tabs": "^1.1.1",
    "@radix-ui/react-toast": "^1.2.2",
    "@radix-ui/react-tooltip": "^1.1.3",
    "@vercel/postgres": "^0.10.0",
    "axios": "^1.7.7",
    "bcrypt": "^5.1.1",
    "bcryptjs": "^2.4.3",
    "class-variance-authority": "^0.7.0",
    "clsx": "^2.1.1",
    "date-fns": "^4.1.0",
    "lucide-react": "^0.451.0",
    "next": "14.2.14",
    "next-auth": "^4.24.8",
    "next-themes": "^0.3.0",
    "open": "^10.1.0",
    "openai": "^4.67.1",
    "react": "^18",
    "react-dom": "^18",
    "react-hook-form": "^7.53.0",
    "recharts": "^2.13.0",
    "tailwind-merge": "^2.5.3",
    "tailwindcss-animate": "^1.0.7",
    "vercel": "^37.8.0",
    "zod": "^3.23.8"
  },
  "devDependencies": {
    "@testing-library/jest-dom": "^6.6.2",
    "@testing-library/react": "^16.0.1",
    "@types/axios": "^0.9.36",
    "@types/bcryptjs": "^2.4.6",
    "@types/jest": "^29.5.13",
    "@types/node": "^20.16.11",
    "@types/react": "^18.3.11",
    "@types/react-dom": "^18",
    "eslint": "^8",
    "eslint-config-next": "14.2.14",
    "jest": "^29.7.0",
    "jest-environment-jsdom": "^29.7.0",
    "postcss": "^8",
    "prisma": "^5.20.0",
    "tailwindcss": "^3.4.1",
    "ts-node": "^10.9.2",
    "typescript": "^5.6.2"
  }
}

================
File: postcss.config.mjs
================
/** @type {import('postcss-load-config').Config} */
const config = {
  plugins: {
    tailwindcss: {},
  },
};

export default config;

================
File: README.md
================
This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically optimize and load [Geist](https://vercel.com/font), a new font family for Vercel.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details.

================
File: tailwind.config.ts
================
import type { Config } from "tailwindcss";

const config: Config = {
    darkMode: ["class"],
    content: [
    "./pages/**/*.{js,ts,jsx,tsx,mdx}",
    "./components/**/*.{js,ts,jsx,tsx,mdx}",
    "./app/**/*.{js,ts,jsx,tsx,mdx}",
  ],
  theme: {
  	extend: {
  		colors: {
  			background: 'hsl(var(--background))',
  			foreground: 'hsl(var(--foreground))',
  			card: {
  				DEFAULT: 'hsl(var(--card))',
  				foreground: 'hsl(var(--card-foreground))'
  			},
  			popover: {
  				DEFAULT: 'hsl(var(--popover))',
  				foreground: 'hsl(var(--popover-foreground))'
  			},
  			primary: {
  				DEFAULT: 'hsl(var(--primary))',
  				foreground: 'hsl(var(--primary-foreground))'
  			},
  			secondary: {
  				DEFAULT: 'hsl(var(--secondary))',
  				foreground: 'hsl(var(--secondary-foreground))'
  			},
  			muted: {
  				DEFAULT: 'hsl(var(--muted))',
  				foreground: 'hsl(var(--muted-foreground))'
  			},
  			accent: {
  				DEFAULT: 'hsl(var(--accent))',
  				foreground: 'hsl(var(--accent-foreground))'
  			},
  			destructive: {
  				DEFAULT: 'hsl(var(--destructive))',
  				foreground: 'hsl(var(--destructive-foreground))'
  			},
  			border: 'hsl(var(--border))',
  			input: 'hsl(var(--input))',
  			ring: 'hsl(var(--ring))',
  			chart: {
  				'1': 'hsl(var(--chart-1))',
  				'2': 'hsl(var(--chart-2))',
  				'3': 'hsl(var(--chart-3))',
  				'4': 'hsl(var(--chart-4))',
  				'5': 'hsl(var(--chart-5))'
  			},
				logo: {
					blue: '#3B82F6',
					purple: '#8B5CF6'
				}
  		},
  		borderRadius: {
  			lg: 'var(--radius)',
  			md: 'calc(var(--radius) - 2px)',
  			sm: 'calc(var(--radius) - 4px)'
  		}
  	}
  },
  plugins: [require("tailwindcss-animate")],
};
export default config;

================
File: tsconfig-scripts.json
================
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "module": "commonjs",
    "moduleResolution": "node",
    "esModuleInterop": true
  },
  "include": ["scripts/**/*"]
}

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "typeRoots": ["./node_modules/@types", "./types"],
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    },
    "types": ["jest", "node"]
  },
  "include": [
    "next-env.d.ts",
    "env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts",
    "types/**/*.d.ts"
  ],
  "exclude": ["node_modules"]
}
